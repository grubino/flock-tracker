/**
 * Generated by orval v7.12.2 ðŸº
 * Do not edit manually.
 * Flock Tracker API
 * 
    ## Flock Tracker API

    A comprehensive API for tracking farm animals, events, and locations.

    ### Features:
    * **Animal Management**: Track sheep, chickens, and bees with lineage information
    * **Event Tracking**: Record health events, treatments, breeding, and more
    * **Location Management**: Manage paddocks and locations with capacity tracking
    * **Search & Filter**: Powerful search and filtering capabilities

    ### Animal Types:
    * **Sheep**: Track lineage, health events, and location with gender tracking (ewes/rams)
    * **Chickens**: Monitor flock health and egg production
    * **Hives**: Track hive health and honey production
    
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AdminUserResponse,
  Animal,
  AnimalCreate,
  AnimalType,
  AnimalUpdate,
  AnimalWithDetails,
  AnimalWithLocation,
  AuthResponse,
  BodyUploadPhotographApiPhotographsUploadAnimalIdPost,
  BodyUploadReceiptApiReceiptsUploadPost,
  Event,
  EventBulkCreate,
  EventCreate,
  EventType,
  EventUpdate,
  EventWithAnimal,
  ExpenseCreate,
  ExpenseResponse,
  ExpenseUpdate,
  GetAvailableLocationsApiLocationsAvailableGetParams,
  GetReceiptsApiReceiptsGetParams,
  GetRecentEventsApiEventsRecentGetParams,
  HTTPValidationError,
  ListExpensesApiExpensesGetParams,
  ListUsersApiAdminUsersGetParams,
  ListVendorsApiVendorsGetParams,
  Location,
  LocationCreate,
  LocationUpdate,
  LocationWithAnimals,
  MoveAnimalToLocationApiAnimalsAnimalIdMovePostParams,
  MoveAnimalsBetweenLocationsApiLocationsMoveAnimalsPostParams,
  Photograph,
  PhotographUpdate,
  PhotographUploadResponse,
  ReadAnimalsApiAnimalsGetParams,
  ReadEventsApiEventsGetParams,
  ReadLocationsApiLocationsGetParams,
  ReceiptResponse,
  ResetUserPassword,
  SearchAnimalsApiAnimalsSearchGetParams,
  SearchEventsApiEventsSearchGetParams,
  SearchLocationsApiLocationsSearchGetParams,
  Token,
  UpdateUserRole,
  UserCreate,
  UserLogin,
  UserResponse,
  VendorCreate,
  VendorResponse,
  VendorUpdate
} from './models';

import { apiClient } from '../services/api-client';




/**
 * Register a new user
 * @summary Register
 */
export const registerApiAuthRegisterPost = (
    userCreate: UserCreate,
 signal?: AbortSignal
) => {
      
      
      return apiClient<AuthResponse>(
      {url: `/api/auth/register`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userCreate, signal
    },
      );
    }
  


export const getRegisterApiAuthRegisterPostMutationOptions = <TError = void | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerApiAuthRegisterPost>>, TError,{data: UserCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof registerApiAuthRegisterPost>>, TError,{data: UserCreate}, TContext> => {

const mutationKey = ['registerApiAuthRegisterPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof registerApiAuthRegisterPost>>, {data: UserCreate}> = (props) => {
          const {data} = props ?? {};

          return  registerApiAuthRegisterPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RegisterApiAuthRegisterPostMutationResult = NonNullable<Awaited<ReturnType<typeof registerApiAuthRegisterPost>>>
    export type RegisterApiAuthRegisterPostMutationBody = UserCreate
    export type RegisterApiAuthRegisterPostMutationError = void | HTTPValidationError

    /**
 * @summary Register
 */
export const useRegisterApiAuthRegisterPost = <TError = void | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerApiAuthRegisterPost>>, TError,{data: UserCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof registerApiAuthRegisterPost>>,
        TError,
        {data: UserCreate},
        TContext
      > => {

      const mutationOptions = getRegisterApiAuthRegisterPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Login with email and password
 * @summary Login
 */
export const loginApiAuthLoginPost = (
    userLogin: UserLogin,
 signal?: AbortSignal
) => {
      
      
      return apiClient<AuthResponse>(
      {url: `/api/auth/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userLogin, signal
    },
      );
    }
  


export const getLoginApiAuthLoginPostMutationOptions = <TError = void | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginApiAuthLoginPost>>, TError,{data: UserLogin}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof loginApiAuthLoginPost>>, TError,{data: UserLogin}, TContext> => {

const mutationKey = ['loginApiAuthLoginPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof loginApiAuthLoginPost>>, {data: UserLogin}> = (props) => {
          const {data} = props ?? {};

          return  loginApiAuthLoginPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginApiAuthLoginPostMutationResult = NonNullable<Awaited<ReturnType<typeof loginApiAuthLoginPost>>>
    export type LoginApiAuthLoginPostMutationBody = UserLogin
    export type LoginApiAuthLoginPostMutationError = void | HTTPValidationError

    /**
 * @summary Login
 */
export const useLoginApiAuthLoginPost = <TError = void | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginApiAuthLoginPost>>, TError,{data: UserLogin}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof loginApiAuthLoginPost>>,
        TError,
        {data: UserLogin},
        TContext
      > => {

      const mutationOptions = getLoginApiAuthLoginPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get current user information
 * @summary Read Users Me
 */
export const readUsersMeApiAuthMeGet = (
    
 signal?: AbortSignal
) => {
      
      
      return apiClient<UserResponse>(
      {url: `/api/auth/me`, method: 'GET', signal
    },
      );
    }
  

export const getReadUsersMeApiAuthMeGetQueryKey = () => {
    return [`/api/auth/me`] as const;
    }

    
export const getReadUsersMeApiAuthMeGetQueryOptions = <TData = Awaited<ReturnType<typeof readUsersMeApiAuthMeGet>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readUsersMeApiAuthMeGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadUsersMeApiAuthMeGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readUsersMeApiAuthMeGet>>> = ({ signal }) => readUsersMeApiAuthMeGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readUsersMeApiAuthMeGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadUsersMeApiAuthMeGetQueryResult = NonNullable<Awaited<ReturnType<typeof readUsersMeApiAuthMeGet>>>
export type ReadUsersMeApiAuthMeGetQueryError = void


export function useReadUsersMeApiAuthMeGet<TData = Awaited<ReturnType<typeof readUsersMeApiAuthMeGet>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readUsersMeApiAuthMeGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readUsersMeApiAuthMeGet>>,
          TError,
          Awaited<ReturnType<typeof readUsersMeApiAuthMeGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadUsersMeApiAuthMeGet<TData = Awaited<ReturnType<typeof readUsersMeApiAuthMeGet>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readUsersMeApiAuthMeGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readUsersMeApiAuthMeGet>>,
          TError,
          Awaited<ReturnType<typeof readUsersMeApiAuthMeGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadUsersMeApiAuthMeGet<TData = Awaited<ReturnType<typeof readUsersMeApiAuthMeGet>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readUsersMeApiAuthMeGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Users Me
 */

export function useReadUsersMeApiAuthMeGet<TData = Awaited<ReturnType<typeof readUsersMeApiAuthMeGet>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readUsersMeApiAuthMeGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadUsersMeApiAuthMeGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Login endpoint that returns just the token (for OAuth2 compatibility)
 * @summary Login For Access Token
 */
export const loginForAccessTokenApiAuthTokenPost = (
    userLogin: UserLogin,
 signal?: AbortSignal
) => {
      
      
      return apiClient<Token>(
      {url: `/api/auth/token`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userLogin, signal
    },
      );
    }
  


export const getLoginForAccessTokenApiAuthTokenPostMutationOptions = <TError = void | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginForAccessTokenApiAuthTokenPost>>, TError,{data: UserLogin}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof loginForAccessTokenApiAuthTokenPost>>, TError,{data: UserLogin}, TContext> => {

const mutationKey = ['loginForAccessTokenApiAuthTokenPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof loginForAccessTokenApiAuthTokenPost>>, {data: UserLogin}> = (props) => {
          const {data} = props ?? {};

          return  loginForAccessTokenApiAuthTokenPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginForAccessTokenApiAuthTokenPostMutationResult = NonNullable<Awaited<ReturnType<typeof loginForAccessTokenApiAuthTokenPost>>>
    export type LoginForAccessTokenApiAuthTokenPostMutationBody = UserLogin
    export type LoginForAccessTokenApiAuthTokenPostMutationError = void | HTTPValidationError

    /**
 * @summary Login For Access Token
 */
export const useLoginForAccessTokenApiAuthTokenPost = <TError = void | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginForAccessTokenApiAuthTokenPost>>, TError,{data: UserLogin}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof loginForAccessTokenApiAuthTokenPost>>,
        TError,
        {data: UserLogin},
        TContext
      > => {

      const mutationOptions = getLoginForAccessTokenApiAuthTokenPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * List all users (admin only)
 * @summary List Users
 */
export const listUsersApiAdminUsersGet = (
    params?: ListUsersApiAdminUsersGetParams,
 signal?: AbortSignal
) => {
      
      
      return apiClient<AdminUserResponse[]>(
      {url: `/api/admin/users`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getListUsersApiAdminUsersGetQueryKey = (params?: ListUsersApiAdminUsersGetParams,) => {
    return [`/api/admin/users`, ...(params ? [params]: [])] as const;
    }

    
export const getListUsersApiAdminUsersGetQueryOptions = <TData = Awaited<ReturnType<typeof listUsersApiAdminUsersGet>>, TError = void | HTTPValidationError>(params?: ListUsersApiAdminUsersGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsersApiAdminUsersGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListUsersApiAdminUsersGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listUsersApiAdminUsersGet>>> = ({ signal }) => listUsersApiAdminUsersGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listUsersApiAdminUsersGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListUsersApiAdminUsersGetQueryResult = NonNullable<Awaited<ReturnType<typeof listUsersApiAdminUsersGet>>>
export type ListUsersApiAdminUsersGetQueryError = void | HTTPValidationError


export function useListUsersApiAdminUsersGet<TData = Awaited<ReturnType<typeof listUsersApiAdminUsersGet>>, TError = void | HTTPValidationError>(
 params: undefined |  ListUsersApiAdminUsersGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsersApiAdminUsersGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listUsersApiAdminUsersGet>>,
          TError,
          Awaited<ReturnType<typeof listUsersApiAdminUsersGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListUsersApiAdminUsersGet<TData = Awaited<ReturnType<typeof listUsersApiAdminUsersGet>>, TError = void | HTTPValidationError>(
 params?: ListUsersApiAdminUsersGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsersApiAdminUsersGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listUsersApiAdminUsersGet>>,
          TError,
          Awaited<ReturnType<typeof listUsersApiAdminUsersGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListUsersApiAdminUsersGet<TData = Awaited<ReturnType<typeof listUsersApiAdminUsersGet>>, TError = void | HTTPValidationError>(
 params?: ListUsersApiAdminUsersGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsersApiAdminUsersGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Users
 */

export function useListUsersApiAdminUsersGet<TData = Awaited<ReturnType<typeof listUsersApiAdminUsersGet>>, TError = void | HTTPValidationError>(
 params?: ListUsersApiAdminUsersGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsersApiAdminUsersGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListUsersApiAdminUsersGetQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get a specific user by ID (admin only)
 * @summary Get User
 */
export const getUserApiAdminUsersUserIdGet = (
    userId: number,
 signal?: AbortSignal
) => {
      
      
      return apiClient<AdminUserResponse>(
      {url: `/api/admin/users/${userId}`, method: 'GET', signal
    },
      );
    }
  

export const getGetUserApiAdminUsersUserIdGetQueryKey = (userId?: number,) => {
    return [`/api/admin/users/${userId}`] as const;
    }

    
export const getGetUserApiAdminUsersUserIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getUserApiAdminUsersUserIdGet>>, TError = void | HTTPValidationError>(userId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserApiAdminUsersUserIdGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserApiAdminUsersUserIdGetQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserApiAdminUsersUserIdGet>>> = ({ signal }) => getUserApiAdminUsersUserIdGet(userId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserApiAdminUsersUserIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserApiAdminUsersUserIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getUserApiAdminUsersUserIdGet>>>
export type GetUserApiAdminUsersUserIdGetQueryError = void | HTTPValidationError


export function useGetUserApiAdminUsersUserIdGet<TData = Awaited<ReturnType<typeof getUserApiAdminUsersUserIdGet>>, TError = void | HTTPValidationError>(
 userId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserApiAdminUsersUserIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserApiAdminUsersUserIdGet>>,
          TError,
          Awaited<ReturnType<typeof getUserApiAdminUsersUserIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserApiAdminUsersUserIdGet<TData = Awaited<ReturnType<typeof getUserApiAdminUsersUserIdGet>>, TError = void | HTTPValidationError>(
 userId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserApiAdminUsersUserIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserApiAdminUsersUserIdGet>>,
          TError,
          Awaited<ReturnType<typeof getUserApiAdminUsersUserIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserApiAdminUsersUserIdGet<TData = Awaited<ReturnType<typeof getUserApiAdminUsersUserIdGet>>, TError = void | HTTPValidationError>(
 userId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserApiAdminUsersUserIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get User
 */

export function useGetUserApiAdminUsersUserIdGet<TData = Awaited<ReturnType<typeof getUserApiAdminUsersUserIdGet>>, TError = void | HTTPValidationError>(
 userId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserApiAdminUsersUserIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserApiAdminUsersUserIdGetQueryOptions(userId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update a user's role (admin only)
 * @summary Update User Role
 */
export const updateUserRoleApiAdminUsersUserIdRolePatch = (
    userId: number,
    updateUserRole: UpdateUserRole,
 ) => {
      
      
      return apiClient<AdminUserResponse>(
      {url: `/api/admin/users/${userId}/role`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateUserRole
    },
      );
    }
  


export const getUpdateUserRoleApiAdminUsersUserIdRolePatchMutationOptions = <TError = void | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUserRoleApiAdminUsersUserIdRolePatch>>, TError,{userId: number;data: UpdateUserRole}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateUserRoleApiAdminUsersUserIdRolePatch>>, TError,{userId: number;data: UpdateUserRole}, TContext> => {

const mutationKey = ['updateUserRoleApiAdminUsersUserIdRolePatch'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUserRoleApiAdminUsersUserIdRolePatch>>, {userId: number;data: UpdateUserRole}> = (props) => {
          const {userId,data} = props ?? {};

          return  updateUserRoleApiAdminUsersUserIdRolePatch(userId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateUserRoleApiAdminUsersUserIdRolePatchMutationResult = NonNullable<Awaited<ReturnType<typeof updateUserRoleApiAdminUsersUserIdRolePatch>>>
    export type UpdateUserRoleApiAdminUsersUserIdRolePatchMutationBody = UpdateUserRole
    export type UpdateUserRoleApiAdminUsersUserIdRolePatchMutationError = void | HTTPValidationError

    /**
 * @summary Update User Role
 */
export const useUpdateUserRoleApiAdminUsersUserIdRolePatch = <TError = void | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUserRoleApiAdminUsersUserIdRolePatch>>, TError,{userId: number;data: UpdateUserRole}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateUserRoleApiAdminUsersUserIdRolePatch>>,
        TError,
        {userId: number;data: UpdateUserRole},
        TContext
      > => {

      const mutationOptions = getUpdateUserRoleApiAdminUsersUserIdRolePatchMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Reset a user's password (admin only)
 * @summary Reset User Password
 */
export const resetUserPasswordApiAdminUsersUserIdResetPasswordPost = (
    userId: number,
    resetUserPassword: ResetUserPassword,
 signal?: AbortSignal
) => {
      
      
      return apiClient<AdminUserResponse>(
      {url: `/api/admin/users/${userId}/reset-password`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: resetUserPassword, signal
    },
      );
    }
  


export const getResetUserPasswordApiAdminUsersUserIdResetPasswordPostMutationOptions = <TError = void | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetUserPasswordApiAdminUsersUserIdResetPasswordPost>>, TError,{userId: number;data: ResetUserPassword}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof resetUserPasswordApiAdminUsersUserIdResetPasswordPost>>, TError,{userId: number;data: ResetUserPassword}, TContext> => {

const mutationKey = ['resetUserPasswordApiAdminUsersUserIdResetPasswordPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof resetUserPasswordApiAdminUsersUserIdResetPasswordPost>>, {userId: number;data: ResetUserPassword}> = (props) => {
          const {userId,data} = props ?? {};

          return  resetUserPasswordApiAdminUsersUserIdResetPasswordPost(userId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ResetUserPasswordApiAdminUsersUserIdResetPasswordPostMutationResult = NonNullable<Awaited<ReturnType<typeof resetUserPasswordApiAdminUsersUserIdResetPasswordPost>>>
    export type ResetUserPasswordApiAdminUsersUserIdResetPasswordPostMutationBody = ResetUserPassword
    export type ResetUserPasswordApiAdminUsersUserIdResetPasswordPostMutationError = void | HTTPValidationError

    /**
 * @summary Reset User Password
 */
export const useResetUserPasswordApiAdminUsersUserIdResetPasswordPost = <TError = void | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetUserPasswordApiAdminUsersUserIdResetPasswordPost>>, TError,{userId: number;data: ResetUserPassword}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof resetUserPasswordApiAdminUsersUserIdResetPasswordPost>>,
        TError,
        {userId: number;data: ResetUserPassword},
        TContext
      > => {

      const mutationOptions = getResetUserPasswordApiAdminUsersUserIdResetPasswordPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Activate a user (admin only)
 * @summary Activate User
 */
export const activateUserApiAdminUsersUserIdActivatePatch = (
    userId: number,
 ) => {
      
      
      return apiClient<AdminUserResponse>(
      {url: `/api/admin/users/${userId}/activate`, method: 'PATCH'
    },
      );
    }
  


export const getActivateUserApiAdminUsersUserIdActivatePatchMutationOptions = <TError = void | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof activateUserApiAdminUsersUserIdActivatePatch>>, TError,{userId: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof activateUserApiAdminUsersUserIdActivatePatch>>, TError,{userId: number}, TContext> => {

const mutationKey = ['activateUserApiAdminUsersUserIdActivatePatch'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof activateUserApiAdminUsersUserIdActivatePatch>>, {userId: number}> = (props) => {
          const {userId} = props ?? {};

          return  activateUserApiAdminUsersUserIdActivatePatch(userId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ActivateUserApiAdminUsersUserIdActivatePatchMutationResult = NonNullable<Awaited<ReturnType<typeof activateUserApiAdminUsersUserIdActivatePatch>>>
    
    export type ActivateUserApiAdminUsersUserIdActivatePatchMutationError = void | HTTPValidationError

    /**
 * @summary Activate User
 */
export const useActivateUserApiAdminUsersUserIdActivatePatch = <TError = void | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof activateUserApiAdminUsersUserIdActivatePatch>>, TError,{userId: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof activateUserApiAdminUsersUserIdActivatePatch>>,
        TError,
        {userId: number},
        TContext
      > => {

      const mutationOptions = getActivateUserApiAdminUsersUserIdActivatePatchMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Deactivate a user (admin only)
 * @summary Deactivate User
 */
export const deactivateUserApiAdminUsersUserIdDeactivatePatch = (
    userId: number,
 ) => {
      
      
      return apiClient<AdminUserResponse>(
      {url: `/api/admin/users/${userId}/deactivate`, method: 'PATCH'
    },
      );
    }
  


export const getDeactivateUserApiAdminUsersUserIdDeactivatePatchMutationOptions = <TError = void | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deactivateUserApiAdminUsersUserIdDeactivatePatch>>, TError,{userId: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deactivateUserApiAdminUsersUserIdDeactivatePatch>>, TError,{userId: number}, TContext> => {

const mutationKey = ['deactivateUserApiAdminUsersUserIdDeactivatePatch'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deactivateUserApiAdminUsersUserIdDeactivatePatch>>, {userId: number}> = (props) => {
          const {userId} = props ?? {};

          return  deactivateUserApiAdminUsersUserIdDeactivatePatch(userId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeactivateUserApiAdminUsersUserIdDeactivatePatchMutationResult = NonNullable<Awaited<ReturnType<typeof deactivateUserApiAdminUsersUserIdDeactivatePatch>>>
    
    export type DeactivateUserApiAdminUsersUserIdDeactivatePatchMutationError = void | HTTPValidationError

    /**
 * @summary Deactivate User
 */
export const useDeactivateUserApiAdminUsersUserIdDeactivatePatch = <TError = void | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deactivateUserApiAdminUsersUserIdDeactivatePatch>>, TError,{userId: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deactivateUserApiAdminUsersUserIdDeactivatePatch>>,
        TError,
        {userId: number},
        TContext
      > => {

      const mutationOptions = getDeactivateUserApiAdminUsersUserIdDeactivatePatchMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get all animals with optional filtering
 * @summary Read Animals
 */
export const readAnimalsApiAnimalsGet = (
    params?: ReadAnimalsApiAnimalsGetParams,
 signal?: AbortSignal
) => {
      
      
      return apiClient<AnimalWithDetails[]>(
      {url: `/api/animals`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getReadAnimalsApiAnimalsGetQueryKey = (params?: ReadAnimalsApiAnimalsGetParams,) => {
    return [`/api/animals`, ...(params ? [params]: [])] as const;
    }

    
export const getReadAnimalsApiAnimalsGetQueryOptions = <TData = Awaited<ReturnType<typeof readAnimalsApiAnimalsGet>>, TError = HTTPValidationError>(params?: ReadAnimalsApiAnimalsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readAnimalsApiAnimalsGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadAnimalsApiAnimalsGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readAnimalsApiAnimalsGet>>> = ({ signal }) => readAnimalsApiAnimalsGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readAnimalsApiAnimalsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadAnimalsApiAnimalsGetQueryResult = NonNullable<Awaited<ReturnType<typeof readAnimalsApiAnimalsGet>>>
export type ReadAnimalsApiAnimalsGetQueryError = HTTPValidationError


export function useReadAnimalsApiAnimalsGet<TData = Awaited<ReturnType<typeof readAnimalsApiAnimalsGet>>, TError = HTTPValidationError>(
 params: undefined |  ReadAnimalsApiAnimalsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readAnimalsApiAnimalsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readAnimalsApiAnimalsGet>>,
          TError,
          Awaited<ReturnType<typeof readAnimalsApiAnimalsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadAnimalsApiAnimalsGet<TData = Awaited<ReturnType<typeof readAnimalsApiAnimalsGet>>, TError = HTTPValidationError>(
 params?: ReadAnimalsApiAnimalsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readAnimalsApiAnimalsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readAnimalsApiAnimalsGet>>,
          TError,
          Awaited<ReturnType<typeof readAnimalsApiAnimalsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadAnimalsApiAnimalsGet<TData = Awaited<ReturnType<typeof readAnimalsApiAnimalsGet>>, TError = HTTPValidationError>(
 params?: ReadAnimalsApiAnimalsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readAnimalsApiAnimalsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Animals
 */

export function useReadAnimalsApiAnimalsGet<TData = Awaited<ReturnType<typeof readAnimalsApiAnimalsGet>>, TError = HTTPValidationError>(
 params?: ReadAnimalsApiAnimalsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readAnimalsApiAnimalsGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadAnimalsApiAnimalsGetQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new animal
 * @summary Create Animal
 */
export const createAnimalApiAnimalsPost = (
    animalCreate: AnimalCreate,
 signal?: AbortSignal
) => {
      
      
      return apiClient<Animal>(
      {url: `/api/animals`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: animalCreate, signal
    },
      );
    }
  


export const getCreateAnimalApiAnimalsPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAnimalApiAnimalsPost>>, TError,{data: AnimalCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createAnimalApiAnimalsPost>>, TError,{data: AnimalCreate}, TContext> => {

const mutationKey = ['createAnimalApiAnimalsPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAnimalApiAnimalsPost>>, {data: AnimalCreate}> = (props) => {
          const {data} = props ?? {};

          return  createAnimalApiAnimalsPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAnimalApiAnimalsPostMutationResult = NonNullable<Awaited<ReturnType<typeof createAnimalApiAnimalsPost>>>
    export type CreateAnimalApiAnimalsPostMutationBody = AnimalCreate
    export type CreateAnimalApiAnimalsPostMutationError = HTTPValidationError

    /**
 * @summary Create Animal
 */
export const useCreateAnimalApiAnimalsPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAnimalApiAnimalsPost>>, TError,{data: AnimalCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAnimalApiAnimalsPost>>,
        TError,
        {data: AnimalCreate},
        TContext
      > => {

      const mutationOptions = getCreateAnimalApiAnimalsPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Search animals by name or tag number
 * @summary Search Animals
 */
export const searchAnimalsApiAnimalsSearchGet = (
    params: SearchAnimalsApiAnimalsSearchGetParams,
 signal?: AbortSignal
) => {
      
      
      return apiClient<unknown>(
      {url: `/api/animals/search`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getSearchAnimalsApiAnimalsSearchGetQueryKey = (params?: SearchAnimalsApiAnimalsSearchGetParams,) => {
    return [`/api/animals/search`, ...(params ? [params]: [])] as const;
    }

    
export const getSearchAnimalsApiAnimalsSearchGetQueryOptions = <TData = Awaited<ReturnType<typeof searchAnimalsApiAnimalsSearchGet>>, TError = HTTPValidationError>(params: SearchAnimalsApiAnimalsSearchGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchAnimalsApiAnimalsSearchGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchAnimalsApiAnimalsSearchGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchAnimalsApiAnimalsSearchGet>>> = ({ signal }) => searchAnimalsApiAnimalsSearchGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchAnimalsApiAnimalsSearchGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SearchAnimalsApiAnimalsSearchGetQueryResult = NonNullable<Awaited<ReturnType<typeof searchAnimalsApiAnimalsSearchGet>>>
export type SearchAnimalsApiAnimalsSearchGetQueryError = HTTPValidationError


export function useSearchAnimalsApiAnimalsSearchGet<TData = Awaited<ReturnType<typeof searchAnimalsApiAnimalsSearchGet>>, TError = HTTPValidationError>(
 params: SearchAnimalsApiAnimalsSearchGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchAnimalsApiAnimalsSearchGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchAnimalsApiAnimalsSearchGet>>,
          TError,
          Awaited<ReturnType<typeof searchAnimalsApiAnimalsSearchGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchAnimalsApiAnimalsSearchGet<TData = Awaited<ReturnType<typeof searchAnimalsApiAnimalsSearchGet>>, TError = HTTPValidationError>(
 params: SearchAnimalsApiAnimalsSearchGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchAnimalsApiAnimalsSearchGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchAnimalsApiAnimalsSearchGet>>,
          TError,
          Awaited<ReturnType<typeof searchAnimalsApiAnimalsSearchGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchAnimalsApiAnimalsSearchGet<TData = Awaited<ReturnType<typeof searchAnimalsApiAnimalsSearchGet>>, TError = HTTPValidationError>(
 params: SearchAnimalsApiAnimalsSearchGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchAnimalsApiAnimalsSearchGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Search Animals
 */

export function useSearchAnimalsApiAnimalsSearchGet<TData = Awaited<ReturnType<typeof searchAnimalsApiAnimalsSearchGet>>, TError = HTTPValidationError>(
 params: SearchAnimalsApiAnimalsSearchGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchAnimalsApiAnimalsSearchGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSearchAnimalsApiAnimalsSearchGetQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get all animals of a specific type
 * @summary Get Animals By Type
 */
export const getAnimalsByTypeApiAnimalsTypeAnimalTypeGet = (
    animalType: AnimalType,
 signal?: AbortSignal
) => {
      
      
      return apiClient<Animal[]>(
      {url: `/api/animals/type/${animalType}`, method: 'GET', signal
    },
      );
    }
  

export const getGetAnimalsByTypeApiAnimalsTypeAnimalTypeGetQueryKey = (animalType?: AnimalType,) => {
    return [`/api/animals/type/${animalType}`] as const;
    }

    
export const getGetAnimalsByTypeApiAnimalsTypeAnimalTypeGetQueryOptions = <TData = Awaited<ReturnType<typeof getAnimalsByTypeApiAnimalsTypeAnimalTypeGet>>, TError = HTTPValidationError>(animalType: AnimalType, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimalsByTypeApiAnimalsTypeAnimalTypeGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimalsByTypeApiAnimalsTypeAnimalTypeGetQueryKey(animalType);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimalsByTypeApiAnimalsTypeAnimalTypeGet>>> = ({ signal }) => getAnimalsByTypeApiAnimalsTypeAnimalTypeGet(animalType, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(animalType), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAnimalsByTypeApiAnimalsTypeAnimalTypeGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAnimalsByTypeApiAnimalsTypeAnimalTypeGetQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimalsByTypeApiAnimalsTypeAnimalTypeGet>>>
export type GetAnimalsByTypeApiAnimalsTypeAnimalTypeGetQueryError = HTTPValidationError


export function useGetAnimalsByTypeApiAnimalsTypeAnimalTypeGet<TData = Awaited<ReturnType<typeof getAnimalsByTypeApiAnimalsTypeAnimalTypeGet>>, TError = HTTPValidationError>(
 animalType: AnimalType, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimalsByTypeApiAnimalsTypeAnimalTypeGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAnimalsByTypeApiAnimalsTypeAnimalTypeGet>>,
          TError,
          Awaited<ReturnType<typeof getAnimalsByTypeApiAnimalsTypeAnimalTypeGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAnimalsByTypeApiAnimalsTypeAnimalTypeGet<TData = Awaited<ReturnType<typeof getAnimalsByTypeApiAnimalsTypeAnimalTypeGet>>, TError = HTTPValidationError>(
 animalType: AnimalType, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimalsByTypeApiAnimalsTypeAnimalTypeGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAnimalsByTypeApiAnimalsTypeAnimalTypeGet>>,
          TError,
          Awaited<ReturnType<typeof getAnimalsByTypeApiAnimalsTypeAnimalTypeGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAnimalsByTypeApiAnimalsTypeAnimalTypeGet<TData = Awaited<ReturnType<typeof getAnimalsByTypeApiAnimalsTypeAnimalTypeGet>>, TError = HTTPValidationError>(
 animalType: AnimalType, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimalsByTypeApiAnimalsTypeAnimalTypeGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Animals By Type
 */

export function useGetAnimalsByTypeApiAnimalsTypeAnimalTypeGet<TData = Awaited<ReturnType<typeof getAnimalsByTypeApiAnimalsTypeAnimalTypeGet>>, TError = HTTPValidationError>(
 animalType: AnimalType, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimalsByTypeApiAnimalsTypeAnimalTypeGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAnimalsByTypeApiAnimalsTypeAnimalTypeGetQueryOptions(animalType,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get animal by tag number
 * @summary Read Animal By Tag
 */
export const readAnimalByTagApiAnimalsTagTagNumberGet = (
    tagNumber: string,
 signal?: AbortSignal
) => {
      
      
      return apiClient<AnimalWithLocation>(
      {url: `/api/animals/tag/${tagNumber}`, method: 'GET', signal
    },
      );
    }
  

export const getReadAnimalByTagApiAnimalsTagTagNumberGetQueryKey = (tagNumber?: string,) => {
    return [`/api/animals/tag/${tagNumber}`] as const;
    }

    
export const getReadAnimalByTagApiAnimalsTagTagNumberGetQueryOptions = <TData = Awaited<ReturnType<typeof readAnimalByTagApiAnimalsTagTagNumberGet>>, TError = HTTPValidationError>(tagNumber: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readAnimalByTagApiAnimalsTagTagNumberGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadAnimalByTagApiAnimalsTagTagNumberGetQueryKey(tagNumber);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readAnimalByTagApiAnimalsTagTagNumberGet>>> = ({ signal }) => readAnimalByTagApiAnimalsTagTagNumberGet(tagNumber, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(tagNumber), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readAnimalByTagApiAnimalsTagTagNumberGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadAnimalByTagApiAnimalsTagTagNumberGetQueryResult = NonNullable<Awaited<ReturnType<typeof readAnimalByTagApiAnimalsTagTagNumberGet>>>
export type ReadAnimalByTagApiAnimalsTagTagNumberGetQueryError = HTTPValidationError


export function useReadAnimalByTagApiAnimalsTagTagNumberGet<TData = Awaited<ReturnType<typeof readAnimalByTagApiAnimalsTagTagNumberGet>>, TError = HTTPValidationError>(
 tagNumber: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readAnimalByTagApiAnimalsTagTagNumberGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readAnimalByTagApiAnimalsTagTagNumberGet>>,
          TError,
          Awaited<ReturnType<typeof readAnimalByTagApiAnimalsTagTagNumberGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadAnimalByTagApiAnimalsTagTagNumberGet<TData = Awaited<ReturnType<typeof readAnimalByTagApiAnimalsTagTagNumberGet>>, TError = HTTPValidationError>(
 tagNumber: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readAnimalByTagApiAnimalsTagTagNumberGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readAnimalByTagApiAnimalsTagTagNumberGet>>,
          TError,
          Awaited<ReturnType<typeof readAnimalByTagApiAnimalsTagTagNumberGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadAnimalByTagApiAnimalsTagTagNumberGet<TData = Awaited<ReturnType<typeof readAnimalByTagApiAnimalsTagTagNumberGet>>, TError = HTTPValidationError>(
 tagNumber: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readAnimalByTagApiAnimalsTagTagNumberGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Animal By Tag
 */

export function useReadAnimalByTagApiAnimalsTagTagNumberGet<TData = Awaited<ReturnType<typeof readAnimalByTagApiAnimalsTagTagNumberGet>>, TError = HTTPValidationError>(
 tagNumber: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readAnimalByTagApiAnimalsTagTagNumberGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadAnimalByTagApiAnimalsTagTagNumberGetQueryOptions(tagNumber,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get a single animal with all details
 * @summary Read Animal
 */
export const readAnimalApiAnimalsAnimalIdGet = (
    animalId: number,
 signal?: AbortSignal
) => {
      
      
      return apiClient<AnimalWithDetails>(
      {url: `/api/animals/${animalId}`, method: 'GET', signal
    },
      );
    }
  

export const getReadAnimalApiAnimalsAnimalIdGetQueryKey = (animalId?: number,) => {
    return [`/api/animals/${animalId}`] as const;
    }

    
export const getReadAnimalApiAnimalsAnimalIdGetQueryOptions = <TData = Awaited<ReturnType<typeof readAnimalApiAnimalsAnimalIdGet>>, TError = HTTPValidationError>(animalId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readAnimalApiAnimalsAnimalIdGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadAnimalApiAnimalsAnimalIdGetQueryKey(animalId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readAnimalApiAnimalsAnimalIdGet>>> = ({ signal }) => readAnimalApiAnimalsAnimalIdGet(animalId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(animalId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readAnimalApiAnimalsAnimalIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadAnimalApiAnimalsAnimalIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof readAnimalApiAnimalsAnimalIdGet>>>
export type ReadAnimalApiAnimalsAnimalIdGetQueryError = HTTPValidationError


export function useReadAnimalApiAnimalsAnimalIdGet<TData = Awaited<ReturnType<typeof readAnimalApiAnimalsAnimalIdGet>>, TError = HTTPValidationError>(
 animalId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readAnimalApiAnimalsAnimalIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readAnimalApiAnimalsAnimalIdGet>>,
          TError,
          Awaited<ReturnType<typeof readAnimalApiAnimalsAnimalIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadAnimalApiAnimalsAnimalIdGet<TData = Awaited<ReturnType<typeof readAnimalApiAnimalsAnimalIdGet>>, TError = HTTPValidationError>(
 animalId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readAnimalApiAnimalsAnimalIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readAnimalApiAnimalsAnimalIdGet>>,
          TError,
          Awaited<ReturnType<typeof readAnimalApiAnimalsAnimalIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadAnimalApiAnimalsAnimalIdGet<TData = Awaited<ReturnType<typeof readAnimalApiAnimalsAnimalIdGet>>, TError = HTTPValidationError>(
 animalId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readAnimalApiAnimalsAnimalIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Animal
 */

export function useReadAnimalApiAnimalsAnimalIdGet<TData = Awaited<ReturnType<typeof readAnimalApiAnimalsAnimalIdGet>>, TError = HTTPValidationError>(
 animalId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readAnimalApiAnimalsAnimalIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadAnimalApiAnimalsAnimalIdGetQueryOptions(animalId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an existing animal
 * @summary Update Animal
 */
export const updateAnimalApiAnimalsAnimalIdPut = (
    animalId: number,
    animalUpdate: AnimalUpdate,
 ) => {
      
      
      return apiClient<Animal>(
      {url: `/api/animals/${animalId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: animalUpdate
    },
      );
    }
  


export const getUpdateAnimalApiAnimalsAnimalIdPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAnimalApiAnimalsAnimalIdPut>>, TError,{animalId: number;data: AnimalUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateAnimalApiAnimalsAnimalIdPut>>, TError,{animalId: number;data: AnimalUpdate}, TContext> => {

const mutationKey = ['updateAnimalApiAnimalsAnimalIdPut'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAnimalApiAnimalsAnimalIdPut>>, {animalId: number;data: AnimalUpdate}> = (props) => {
          const {animalId,data} = props ?? {};

          return  updateAnimalApiAnimalsAnimalIdPut(animalId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateAnimalApiAnimalsAnimalIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateAnimalApiAnimalsAnimalIdPut>>>
    export type UpdateAnimalApiAnimalsAnimalIdPutMutationBody = AnimalUpdate
    export type UpdateAnimalApiAnimalsAnimalIdPutMutationError = HTTPValidationError

    /**
 * @summary Update Animal
 */
export const useUpdateAnimalApiAnimalsAnimalIdPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAnimalApiAnimalsAnimalIdPut>>, TError,{animalId: number;data: AnimalUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateAnimalApiAnimalsAnimalIdPut>>,
        TError,
        {animalId: number;data: AnimalUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateAnimalApiAnimalsAnimalIdPutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete an animal
 * @summary Delete Animal
 */
export const deleteAnimalApiAnimalsAnimalIdDelete = (
    animalId: number,
 ) => {
      
      
      return apiClient<unknown>(
      {url: `/api/animals/${animalId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteAnimalApiAnimalsAnimalIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAnimalApiAnimalsAnimalIdDelete>>, TError,{animalId: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteAnimalApiAnimalsAnimalIdDelete>>, TError,{animalId: number}, TContext> => {

const mutationKey = ['deleteAnimalApiAnimalsAnimalIdDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAnimalApiAnimalsAnimalIdDelete>>, {animalId: number}> = (props) => {
          const {animalId} = props ?? {};

          return  deleteAnimalApiAnimalsAnimalIdDelete(animalId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAnimalApiAnimalsAnimalIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAnimalApiAnimalsAnimalIdDelete>>>
    
    export type DeleteAnimalApiAnimalsAnimalIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Animal
 */
export const useDeleteAnimalApiAnimalsAnimalIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAnimalApiAnimalsAnimalIdDelete>>, TError,{animalId: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteAnimalApiAnimalsAnimalIdDelete>>,
        TError,
        {animalId: number},
        TContext
      > => {

      const mutationOptions = getDeleteAnimalApiAnimalsAnimalIdDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get all offspring of an animal
 * @summary Get Animal Offspring
 */
export const getAnimalOffspringApiAnimalsAnimalIdOffspringGet = (
    animalId: number,
 signal?: AbortSignal
) => {
      
      
      return apiClient<Animal[]>(
      {url: `/api/animals/${animalId}/offspring`, method: 'GET', signal
    },
      );
    }
  

export const getGetAnimalOffspringApiAnimalsAnimalIdOffspringGetQueryKey = (animalId?: number,) => {
    return [`/api/animals/${animalId}/offspring`] as const;
    }

    
export const getGetAnimalOffspringApiAnimalsAnimalIdOffspringGetQueryOptions = <TData = Awaited<ReturnType<typeof getAnimalOffspringApiAnimalsAnimalIdOffspringGet>>, TError = HTTPValidationError>(animalId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimalOffspringApiAnimalsAnimalIdOffspringGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimalOffspringApiAnimalsAnimalIdOffspringGetQueryKey(animalId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimalOffspringApiAnimalsAnimalIdOffspringGet>>> = ({ signal }) => getAnimalOffspringApiAnimalsAnimalIdOffspringGet(animalId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(animalId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAnimalOffspringApiAnimalsAnimalIdOffspringGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAnimalOffspringApiAnimalsAnimalIdOffspringGetQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimalOffspringApiAnimalsAnimalIdOffspringGet>>>
export type GetAnimalOffspringApiAnimalsAnimalIdOffspringGetQueryError = HTTPValidationError


export function useGetAnimalOffspringApiAnimalsAnimalIdOffspringGet<TData = Awaited<ReturnType<typeof getAnimalOffspringApiAnimalsAnimalIdOffspringGet>>, TError = HTTPValidationError>(
 animalId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimalOffspringApiAnimalsAnimalIdOffspringGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAnimalOffspringApiAnimalsAnimalIdOffspringGet>>,
          TError,
          Awaited<ReturnType<typeof getAnimalOffspringApiAnimalsAnimalIdOffspringGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAnimalOffspringApiAnimalsAnimalIdOffspringGet<TData = Awaited<ReturnType<typeof getAnimalOffspringApiAnimalsAnimalIdOffspringGet>>, TError = HTTPValidationError>(
 animalId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimalOffspringApiAnimalsAnimalIdOffspringGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAnimalOffspringApiAnimalsAnimalIdOffspringGet>>,
          TError,
          Awaited<ReturnType<typeof getAnimalOffspringApiAnimalsAnimalIdOffspringGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAnimalOffspringApiAnimalsAnimalIdOffspringGet<TData = Awaited<ReturnType<typeof getAnimalOffspringApiAnimalsAnimalIdOffspringGet>>, TError = HTTPValidationError>(
 animalId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimalOffspringApiAnimalsAnimalIdOffspringGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Animal Offspring
 */

export function useGetAnimalOffspringApiAnimalsAnimalIdOffspringGet<TData = Awaited<ReturnType<typeof getAnimalOffspringApiAnimalsAnimalIdOffspringGet>>, TError = HTTPValidationError>(
 animalId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimalOffspringApiAnimalsAnimalIdOffspringGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAnimalOffspringApiAnimalsAnimalIdOffspringGetQueryOptions(animalId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Move an animal to a new location
 * @summary Move Animal To Location
 */
export const moveAnimalToLocationApiAnimalsAnimalIdMovePost = (
    animalId: number,
    params: MoveAnimalToLocationApiAnimalsAnimalIdMovePostParams,
 signal?: AbortSignal
) => {
      
      
      return apiClient<unknown>(
      {url: `/api/animals/${animalId}/move`, method: 'POST',
        params, signal
    },
      );
    }
  


export const getMoveAnimalToLocationApiAnimalsAnimalIdMovePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof moveAnimalToLocationApiAnimalsAnimalIdMovePost>>, TError,{animalId: number;params: MoveAnimalToLocationApiAnimalsAnimalIdMovePostParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof moveAnimalToLocationApiAnimalsAnimalIdMovePost>>, TError,{animalId: number;params: MoveAnimalToLocationApiAnimalsAnimalIdMovePostParams}, TContext> => {

const mutationKey = ['moveAnimalToLocationApiAnimalsAnimalIdMovePost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof moveAnimalToLocationApiAnimalsAnimalIdMovePost>>, {animalId: number;params: MoveAnimalToLocationApiAnimalsAnimalIdMovePostParams}> = (props) => {
          const {animalId,params} = props ?? {};

          return  moveAnimalToLocationApiAnimalsAnimalIdMovePost(animalId,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type MoveAnimalToLocationApiAnimalsAnimalIdMovePostMutationResult = NonNullable<Awaited<ReturnType<typeof moveAnimalToLocationApiAnimalsAnimalIdMovePost>>>
    
    export type MoveAnimalToLocationApiAnimalsAnimalIdMovePostMutationError = HTTPValidationError

    /**
 * @summary Move Animal To Location
 */
export const useMoveAnimalToLocationApiAnimalsAnimalIdMovePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof moveAnimalToLocationApiAnimalsAnimalIdMovePost>>, TError,{animalId: number;params: MoveAnimalToLocationApiAnimalsAnimalIdMovePostParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof moveAnimalToLocationApiAnimalsAnimalIdMovePost>>,
        TError,
        {animalId: number;params: MoveAnimalToLocationApiAnimalsAnimalIdMovePostParams},
        TContext
      > => {

      const mutationOptions = getMoveAnimalToLocationApiAnimalsAnimalIdMovePostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get all events with optional filtering
 * @summary Read Events
 */
export const readEventsApiEventsGet = (
    params?: ReadEventsApiEventsGetParams,
 signal?: AbortSignal
) => {
      
      
      return apiClient<EventWithAnimal[]>(
      {url: `/api/events`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getReadEventsApiEventsGetQueryKey = (params?: ReadEventsApiEventsGetParams,) => {
    return [`/api/events`, ...(params ? [params]: [])] as const;
    }

    
export const getReadEventsApiEventsGetQueryOptions = <TData = Awaited<ReturnType<typeof readEventsApiEventsGet>>, TError = HTTPValidationError>(params?: ReadEventsApiEventsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readEventsApiEventsGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadEventsApiEventsGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readEventsApiEventsGet>>> = ({ signal }) => readEventsApiEventsGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readEventsApiEventsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadEventsApiEventsGetQueryResult = NonNullable<Awaited<ReturnType<typeof readEventsApiEventsGet>>>
export type ReadEventsApiEventsGetQueryError = HTTPValidationError


export function useReadEventsApiEventsGet<TData = Awaited<ReturnType<typeof readEventsApiEventsGet>>, TError = HTTPValidationError>(
 params: undefined |  ReadEventsApiEventsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readEventsApiEventsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readEventsApiEventsGet>>,
          TError,
          Awaited<ReturnType<typeof readEventsApiEventsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadEventsApiEventsGet<TData = Awaited<ReturnType<typeof readEventsApiEventsGet>>, TError = HTTPValidationError>(
 params?: ReadEventsApiEventsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readEventsApiEventsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readEventsApiEventsGet>>,
          TError,
          Awaited<ReturnType<typeof readEventsApiEventsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadEventsApiEventsGet<TData = Awaited<ReturnType<typeof readEventsApiEventsGet>>, TError = HTTPValidationError>(
 params?: ReadEventsApiEventsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readEventsApiEventsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Events
 */

export function useReadEventsApiEventsGet<TData = Awaited<ReturnType<typeof readEventsApiEventsGet>>, TError = HTTPValidationError>(
 params?: ReadEventsApiEventsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readEventsApiEventsGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadEventsApiEventsGetQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new event
 * @summary Create Event
 */
export const createEventApiEventsPost = (
    eventCreate: EventCreate,
 signal?: AbortSignal
) => {
      
      
      return apiClient<Event>(
      {url: `/api/events`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: eventCreate, signal
    },
      );
    }
  


export const getCreateEventApiEventsPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createEventApiEventsPost>>, TError,{data: EventCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createEventApiEventsPost>>, TError,{data: EventCreate}, TContext> => {

const mutationKey = ['createEventApiEventsPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createEventApiEventsPost>>, {data: EventCreate}> = (props) => {
          const {data} = props ?? {};

          return  createEventApiEventsPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateEventApiEventsPostMutationResult = NonNullable<Awaited<ReturnType<typeof createEventApiEventsPost>>>
    export type CreateEventApiEventsPostMutationBody = EventCreate
    export type CreateEventApiEventsPostMutationError = HTTPValidationError

    /**
 * @summary Create Event
 */
export const useCreateEventApiEventsPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createEventApiEventsPost>>, TError,{data: EventCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createEventApiEventsPost>>,
        TError,
        {data: EventCreate},
        TContext
      > => {

      const mutationOptions = getCreateEventApiEventsPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Create multiple events at once
 * @summary Create Bulk Events
 */
export const createBulkEventsApiEventsBulkPost = (
    eventBulkCreate: EventBulkCreate,
 signal?: AbortSignal
) => {
      
      
      return apiClient<Event[]>(
      {url: `/api/events/bulk`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: eventBulkCreate, signal
    },
      );
    }
  


export const getCreateBulkEventsApiEventsBulkPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBulkEventsApiEventsBulkPost>>, TError,{data: EventBulkCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createBulkEventsApiEventsBulkPost>>, TError,{data: EventBulkCreate}, TContext> => {

const mutationKey = ['createBulkEventsApiEventsBulkPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createBulkEventsApiEventsBulkPost>>, {data: EventBulkCreate}> = (props) => {
          const {data} = props ?? {};

          return  createBulkEventsApiEventsBulkPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateBulkEventsApiEventsBulkPostMutationResult = NonNullable<Awaited<ReturnType<typeof createBulkEventsApiEventsBulkPost>>>
    export type CreateBulkEventsApiEventsBulkPostMutationBody = EventBulkCreate
    export type CreateBulkEventsApiEventsBulkPostMutationError = HTTPValidationError

    /**
 * @summary Create Bulk Events
 */
export const useCreateBulkEventsApiEventsBulkPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBulkEventsApiEventsBulkPost>>, TError,{data: EventBulkCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createBulkEventsApiEventsBulkPost>>,
        TError,
        {data: EventBulkCreate},
        TContext
      > => {

      const mutationOptions = getCreateBulkEventsApiEventsBulkPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Search events by description, notes, medication, or veterinarian
 * @summary Search Events
 */
export const searchEventsApiEventsSearchGet = (
    params: SearchEventsApiEventsSearchGetParams,
 signal?: AbortSignal
) => {
      
      
      return apiClient<unknown>(
      {url: `/api/events/search`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getSearchEventsApiEventsSearchGetQueryKey = (params?: SearchEventsApiEventsSearchGetParams,) => {
    return [`/api/events/search`, ...(params ? [params]: [])] as const;
    }

    
export const getSearchEventsApiEventsSearchGetQueryOptions = <TData = Awaited<ReturnType<typeof searchEventsApiEventsSearchGet>>, TError = HTTPValidationError>(params: SearchEventsApiEventsSearchGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchEventsApiEventsSearchGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchEventsApiEventsSearchGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchEventsApiEventsSearchGet>>> = ({ signal }) => searchEventsApiEventsSearchGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchEventsApiEventsSearchGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SearchEventsApiEventsSearchGetQueryResult = NonNullable<Awaited<ReturnType<typeof searchEventsApiEventsSearchGet>>>
export type SearchEventsApiEventsSearchGetQueryError = HTTPValidationError


export function useSearchEventsApiEventsSearchGet<TData = Awaited<ReturnType<typeof searchEventsApiEventsSearchGet>>, TError = HTTPValidationError>(
 params: SearchEventsApiEventsSearchGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchEventsApiEventsSearchGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchEventsApiEventsSearchGet>>,
          TError,
          Awaited<ReturnType<typeof searchEventsApiEventsSearchGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchEventsApiEventsSearchGet<TData = Awaited<ReturnType<typeof searchEventsApiEventsSearchGet>>, TError = HTTPValidationError>(
 params: SearchEventsApiEventsSearchGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchEventsApiEventsSearchGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchEventsApiEventsSearchGet>>,
          TError,
          Awaited<ReturnType<typeof searchEventsApiEventsSearchGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchEventsApiEventsSearchGet<TData = Awaited<ReturnType<typeof searchEventsApiEventsSearchGet>>, TError = HTTPValidationError>(
 params: SearchEventsApiEventsSearchGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchEventsApiEventsSearchGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Search Events
 */

export function useSearchEventsApiEventsSearchGet<TData = Awaited<ReturnType<typeof searchEventsApiEventsSearchGet>>, TError = HTTPValidationError>(
 params: SearchEventsApiEventsSearchGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchEventsApiEventsSearchGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSearchEventsApiEventsSearchGetQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get events from the last N days
 * @summary Get Recent Events
 */
export const getRecentEventsApiEventsRecentGet = (
    params?: GetRecentEventsApiEventsRecentGetParams,
 signal?: AbortSignal
) => {
      
      
      return apiClient<unknown>(
      {url: `/api/events/recent`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetRecentEventsApiEventsRecentGetQueryKey = (params?: GetRecentEventsApiEventsRecentGetParams,) => {
    return [`/api/events/recent`, ...(params ? [params]: [])] as const;
    }

    
export const getGetRecentEventsApiEventsRecentGetQueryOptions = <TData = Awaited<ReturnType<typeof getRecentEventsApiEventsRecentGet>>, TError = HTTPValidationError>(params?: GetRecentEventsApiEventsRecentGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentEventsApiEventsRecentGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRecentEventsApiEventsRecentGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecentEventsApiEventsRecentGet>>> = ({ signal }) => getRecentEventsApiEventsRecentGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRecentEventsApiEventsRecentGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRecentEventsApiEventsRecentGetQueryResult = NonNullable<Awaited<ReturnType<typeof getRecentEventsApiEventsRecentGet>>>
export type GetRecentEventsApiEventsRecentGetQueryError = HTTPValidationError


export function useGetRecentEventsApiEventsRecentGet<TData = Awaited<ReturnType<typeof getRecentEventsApiEventsRecentGet>>, TError = HTTPValidationError>(
 params: undefined |  GetRecentEventsApiEventsRecentGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentEventsApiEventsRecentGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecentEventsApiEventsRecentGet>>,
          TError,
          Awaited<ReturnType<typeof getRecentEventsApiEventsRecentGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecentEventsApiEventsRecentGet<TData = Awaited<ReturnType<typeof getRecentEventsApiEventsRecentGet>>, TError = HTTPValidationError>(
 params?: GetRecentEventsApiEventsRecentGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentEventsApiEventsRecentGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecentEventsApiEventsRecentGet>>,
          TError,
          Awaited<ReturnType<typeof getRecentEventsApiEventsRecentGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecentEventsApiEventsRecentGet<TData = Awaited<ReturnType<typeof getRecentEventsApiEventsRecentGet>>, TError = HTTPValidationError>(
 params?: GetRecentEventsApiEventsRecentGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentEventsApiEventsRecentGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Recent Events
 */

export function useGetRecentEventsApiEventsRecentGet<TData = Awaited<ReturnType<typeof getRecentEventsApiEventsRecentGet>>, TError = HTTPValidationError>(
 params?: GetRecentEventsApiEventsRecentGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentEventsApiEventsRecentGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRecentEventsApiEventsRecentGetQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get upcoming scheduled events
 * @summary Get Upcoming Events
 */
export const getUpcomingEventsApiEventsUpcomingGet = (
    
 signal?: AbortSignal
) => {
      
      
      return apiClient<unknown>(
      {url: `/api/events/upcoming`, method: 'GET', signal
    },
      );
    }
  

export const getGetUpcomingEventsApiEventsUpcomingGetQueryKey = () => {
    return [`/api/events/upcoming`] as const;
    }

    
export const getGetUpcomingEventsApiEventsUpcomingGetQueryOptions = <TData = Awaited<ReturnType<typeof getUpcomingEventsApiEventsUpcomingGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUpcomingEventsApiEventsUpcomingGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUpcomingEventsApiEventsUpcomingGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUpcomingEventsApiEventsUpcomingGet>>> = ({ signal }) => getUpcomingEventsApiEventsUpcomingGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUpcomingEventsApiEventsUpcomingGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUpcomingEventsApiEventsUpcomingGetQueryResult = NonNullable<Awaited<ReturnType<typeof getUpcomingEventsApiEventsUpcomingGet>>>
export type GetUpcomingEventsApiEventsUpcomingGetQueryError = unknown


export function useGetUpcomingEventsApiEventsUpcomingGet<TData = Awaited<ReturnType<typeof getUpcomingEventsApiEventsUpcomingGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUpcomingEventsApiEventsUpcomingGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUpcomingEventsApiEventsUpcomingGet>>,
          TError,
          Awaited<ReturnType<typeof getUpcomingEventsApiEventsUpcomingGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUpcomingEventsApiEventsUpcomingGet<TData = Awaited<ReturnType<typeof getUpcomingEventsApiEventsUpcomingGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUpcomingEventsApiEventsUpcomingGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUpcomingEventsApiEventsUpcomingGet>>,
          TError,
          Awaited<ReturnType<typeof getUpcomingEventsApiEventsUpcomingGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUpcomingEventsApiEventsUpcomingGet<TData = Awaited<ReturnType<typeof getUpcomingEventsApiEventsUpcomingGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUpcomingEventsApiEventsUpcomingGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Upcoming Events
 */

export function useGetUpcomingEventsApiEventsUpcomingGet<TData = Awaited<ReturnType<typeof getUpcomingEventsApiEventsUpcomingGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUpcomingEventsApiEventsUpcomingGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUpcomingEventsApiEventsUpcomingGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get all events of a specific type
 * @summary Get Events By Type
 */
export const getEventsByTypeApiEventsTypeEventTypeGet = (
    eventType: EventType,
 signal?: AbortSignal
) => {
      
      
      return apiClient<EventWithAnimal[]>(
      {url: `/api/events/type/${eventType}`, method: 'GET', signal
    },
      );
    }
  

export const getGetEventsByTypeApiEventsTypeEventTypeGetQueryKey = (eventType?: EventType,) => {
    return [`/api/events/type/${eventType}`] as const;
    }

    
export const getGetEventsByTypeApiEventsTypeEventTypeGetQueryOptions = <TData = Awaited<ReturnType<typeof getEventsByTypeApiEventsTypeEventTypeGet>>, TError = HTTPValidationError>(eventType: EventType, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEventsByTypeApiEventsTypeEventTypeGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEventsByTypeApiEventsTypeEventTypeGetQueryKey(eventType);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEventsByTypeApiEventsTypeEventTypeGet>>> = ({ signal }) => getEventsByTypeApiEventsTypeEventTypeGet(eventType, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(eventType), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEventsByTypeApiEventsTypeEventTypeGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEventsByTypeApiEventsTypeEventTypeGetQueryResult = NonNullable<Awaited<ReturnType<typeof getEventsByTypeApiEventsTypeEventTypeGet>>>
export type GetEventsByTypeApiEventsTypeEventTypeGetQueryError = HTTPValidationError


export function useGetEventsByTypeApiEventsTypeEventTypeGet<TData = Awaited<ReturnType<typeof getEventsByTypeApiEventsTypeEventTypeGet>>, TError = HTTPValidationError>(
 eventType: EventType, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEventsByTypeApiEventsTypeEventTypeGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEventsByTypeApiEventsTypeEventTypeGet>>,
          TError,
          Awaited<ReturnType<typeof getEventsByTypeApiEventsTypeEventTypeGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEventsByTypeApiEventsTypeEventTypeGet<TData = Awaited<ReturnType<typeof getEventsByTypeApiEventsTypeEventTypeGet>>, TError = HTTPValidationError>(
 eventType: EventType, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEventsByTypeApiEventsTypeEventTypeGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEventsByTypeApiEventsTypeEventTypeGet>>,
          TError,
          Awaited<ReturnType<typeof getEventsByTypeApiEventsTypeEventTypeGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEventsByTypeApiEventsTypeEventTypeGet<TData = Awaited<ReturnType<typeof getEventsByTypeApiEventsTypeEventTypeGet>>, TError = HTTPValidationError>(
 eventType: EventType, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEventsByTypeApiEventsTypeEventTypeGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Events By Type
 */

export function useGetEventsByTypeApiEventsTypeEventTypeGet<TData = Awaited<ReturnType<typeof getEventsByTypeApiEventsTypeEventTypeGet>>, TError = HTTPValidationError>(
 eventType: EventType, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEventsByTypeApiEventsTypeEventTypeGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetEventsByTypeApiEventsTypeEventTypeGetQueryOptions(eventType,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get a single event by ID
 * @summary Read Event
 */
export const readEventApiEventsEventIdGet = (
    eventId: number,
 signal?: AbortSignal
) => {
      
      
      return apiClient<EventWithAnimal>(
      {url: `/api/events/${eventId}`, method: 'GET', signal
    },
      );
    }
  

export const getReadEventApiEventsEventIdGetQueryKey = (eventId?: number,) => {
    return [`/api/events/${eventId}`] as const;
    }

    
export const getReadEventApiEventsEventIdGetQueryOptions = <TData = Awaited<ReturnType<typeof readEventApiEventsEventIdGet>>, TError = HTTPValidationError>(eventId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readEventApiEventsEventIdGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadEventApiEventsEventIdGetQueryKey(eventId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readEventApiEventsEventIdGet>>> = ({ signal }) => readEventApiEventsEventIdGet(eventId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(eventId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readEventApiEventsEventIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadEventApiEventsEventIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof readEventApiEventsEventIdGet>>>
export type ReadEventApiEventsEventIdGetQueryError = HTTPValidationError


export function useReadEventApiEventsEventIdGet<TData = Awaited<ReturnType<typeof readEventApiEventsEventIdGet>>, TError = HTTPValidationError>(
 eventId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readEventApiEventsEventIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readEventApiEventsEventIdGet>>,
          TError,
          Awaited<ReturnType<typeof readEventApiEventsEventIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadEventApiEventsEventIdGet<TData = Awaited<ReturnType<typeof readEventApiEventsEventIdGet>>, TError = HTTPValidationError>(
 eventId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readEventApiEventsEventIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readEventApiEventsEventIdGet>>,
          TError,
          Awaited<ReturnType<typeof readEventApiEventsEventIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadEventApiEventsEventIdGet<TData = Awaited<ReturnType<typeof readEventApiEventsEventIdGet>>, TError = HTTPValidationError>(
 eventId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readEventApiEventsEventIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Event
 */

export function useReadEventApiEventsEventIdGet<TData = Awaited<ReturnType<typeof readEventApiEventsEventIdGet>>, TError = HTTPValidationError>(
 eventId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readEventApiEventsEventIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadEventApiEventsEventIdGetQueryOptions(eventId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an existing event
 * @summary Update Event
 */
export const updateEventApiEventsEventIdPut = (
    eventId: number,
    eventUpdate: EventUpdate,
 ) => {
      
      
      return apiClient<Event>(
      {url: `/api/events/${eventId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: eventUpdate
    },
      );
    }
  


export const getUpdateEventApiEventsEventIdPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateEventApiEventsEventIdPut>>, TError,{eventId: number;data: EventUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateEventApiEventsEventIdPut>>, TError,{eventId: number;data: EventUpdate}, TContext> => {

const mutationKey = ['updateEventApiEventsEventIdPut'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateEventApiEventsEventIdPut>>, {eventId: number;data: EventUpdate}> = (props) => {
          const {eventId,data} = props ?? {};

          return  updateEventApiEventsEventIdPut(eventId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateEventApiEventsEventIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateEventApiEventsEventIdPut>>>
    export type UpdateEventApiEventsEventIdPutMutationBody = EventUpdate
    export type UpdateEventApiEventsEventIdPutMutationError = HTTPValidationError

    /**
 * @summary Update Event
 */
export const useUpdateEventApiEventsEventIdPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateEventApiEventsEventIdPut>>, TError,{eventId: number;data: EventUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateEventApiEventsEventIdPut>>,
        TError,
        {eventId: number;data: EventUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateEventApiEventsEventIdPutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete an event
 * @summary Delete Event
 */
export const deleteEventApiEventsEventIdDelete = (
    eventId: number,
 ) => {
      
      
      return apiClient<unknown>(
      {url: `/api/events/${eventId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteEventApiEventsEventIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteEventApiEventsEventIdDelete>>, TError,{eventId: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteEventApiEventsEventIdDelete>>, TError,{eventId: number}, TContext> => {

const mutationKey = ['deleteEventApiEventsEventIdDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteEventApiEventsEventIdDelete>>, {eventId: number}> = (props) => {
          const {eventId} = props ?? {};

          return  deleteEventApiEventsEventIdDelete(eventId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteEventApiEventsEventIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteEventApiEventsEventIdDelete>>>
    
    export type DeleteEventApiEventsEventIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Event
 */
export const useDeleteEventApiEventsEventIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteEventApiEventsEventIdDelete>>, TError,{eventId: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteEventApiEventsEventIdDelete>>,
        TError,
        {eventId: number},
        TContext
      > => {

      const mutationOptions = getDeleteEventApiEventsEventIdDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get all events for a specific animal
 * @summary Read Events By Animal
 */
export const readEventsByAnimalApiEventsAnimalAnimalIdGet = (
    animalId: number,
 signal?: AbortSignal
) => {
      
      
      return apiClient<Event[]>(
      {url: `/api/events/animal/${animalId}`, method: 'GET', signal
    },
      );
    }
  

export const getReadEventsByAnimalApiEventsAnimalAnimalIdGetQueryKey = (animalId?: number,) => {
    return [`/api/events/animal/${animalId}`] as const;
    }

    
export const getReadEventsByAnimalApiEventsAnimalAnimalIdGetQueryOptions = <TData = Awaited<ReturnType<typeof readEventsByAnimalApiEventsAnimalAnimalIdGet>>, TError = HTTPValidationError>(animalId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readEventsByAnimalApiEventsAnimalAnimalIdGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadEventsByAnimalApiEventsAnimalAnimalIdGetQueryKey(animalId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readEventsByAnimalApiEventsAnimalAnimalIdGet>>> = ({ signal }) => readEventsByAnimalApiEventsAnimalAnimalIdGet(animalId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(animalId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readEventsByAnimalApiEventsAnimalAnimalIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadEventsByAnimalApiEventsAnimalAnimalIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof readEventsByAnimalApiEventsAnimalAnimalIdGet>>>
export type ReadEventsByAnimalApiEventsAnimalAnimalIdGetQueryError = HTTPValidationError


export function useReadEventsByAnimalApiEventsAnimalAnimalIdGet<TData = Awaited<ReturnType<typeof readEventsByAnimalApiEventsAnimalAnimalIdGet>>, TError = HTTPValidationError>(
 animalId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readEventsByAnimalApiEventsAnimalAnimalIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readEventsByAnimalApiEventsAnimalAnimalIdGet>>,
          TError,
          Awaited<ReturnType<typeof readEventsByAnimalApiEventsAnimalAnimalIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadEventsByAnimalApiEventsAnimalAnimalIdGet<TData = Awaited<ReturnType<typeof readEventsByAnimalApiEventsAnimalAnimalIdGet>>, TError = HTTPValidationError>(
 animalId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readEventsByAnimalApiEventsAnimalAnimalIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readEventsByAnimalApiEventsAnimalAnimalIdGet>>,
          TError,
          Awaited<ReturnType<typeof readEventsByAnimalApiEventsAnimalAnimalIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadEventsByAnimalApiEventsAnimalAnimalIdGet<TData = Awaited<ReturnType<typeof readEventsByAnimalApiEventsAnimalAnimalIdGet>>, TError = HTTPValidationError>(
 animalId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readEventsByAnimalApiEventsAnimalAnimalIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Events By Animal
 */

export function useReadEventsByAnimalApiEventsAnimalAnimalIdGet<TData = Awaited<ReturnType<typeof readEventsByAnimalApiEventsAnimalAnimalIdGet>>, TError = HTTPValidationError>(
 animalId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readEventsByAnimalApiEventsAnimalAnimalIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadEventsByAnimalApiEventsAnimalAnimalIdGetQueryOptions(animalId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get all health-related events for an animal
 * @summary Get Animal Health Events
 */
export const getAnimalHealthEventsApiEventsAnimalAnimalIdHealthGet = (
    animalId: number,
 signal?: AbortSignal
) => {
      
      
      return apiClient<Event[]>(
      {url: `/api/events/animal/${animalId}/health`, method: 'GET', signal
    },
      );
    }
  

export const getGetAnimalHealthEventsApiEventsAnimalAnimalIdHealthGetQueryKey = (animalId?: number,) => {
    return [`/api/events/animal/${animalId}/health`] as const;
    }

    
export const getGetAnimalHealthEventsApiEventsAnimalAnimalIdHealthGetQueryOptions = <TData = Awaited<ReturnType<typeof getAnimalHealthEventsApiEventsAnimalAnimalIdHealthGet>>, TError = HTTPValidationError>(animalId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimalHealthEventsApiEventsAnimalAnimalIdHealthGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimalHealthEventsApiEventsAnimalAnimalIdHealthGetQueryKey(animalId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimalHealthEventsApiEventsAnimalAnimalIdHealthGet>>> = ({ signal }) => getAnimalHealthEventsApiEventsAnimalAnimalIdHealthGet(animalId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(animalId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAnimalHealthEventsApiEventsAnimalAnimalIdHealthGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAnimalHealthEventsApiEventsAnimalAnimalIdHealthGetQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimalHealthEventsApiEventsAnimalAnimalIdHealthGet>>>
export type GetAnimalHealthEventsApiEventsAnimalAnimalIdHealthGetQueryError = HTTPValidationError


export function useGetAnimalHealthEventsApiEventsAnimalAnimalIdHealthGet<TData = Awaited<ReturnType<typeof getAnimalHealthEventsApiEventsAnimalAnimalIdHealthGet>>, TError = HTTPValidationError>(
 animalId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimalHealthEventsApiEventsAnimalAnimalIdHealthGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAnimalHealthEventsApiEventsAnimalAnimalIdHealthGet>>,
          TError,
          Awaited<ReturnType<typeof getAnimalHealthEventsApiEventsAnimalAnimalIdHealthGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAnimalHealthEventsApiEventsAnimalAnimalIdHealthGet<TData = Awaited<ReturnType<typeof getAnimalHealthEventsApiEventsAnimalAnimalIdHealthGet>>, TError = HTTPValidationError>(
 animalId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimalHealthEventsApiEventsAnimalAnimalIdHealthGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAnimalHealthEventsApiEventsAnimalAnimalIdHealthGet>>,
          TError,
          Awaited<ReturnType<typeof getAnimalHealthEventsApiEventsAnimalAnimalIdHealthGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAnimalHealthEventsApiEventsAnimalAnimalIdHealthGet<TData = Awaited<ReturnType<typeof getAnimalHealthEventsApiEventsAnimalAnimalIdHealthGet>>, TError = HTTPValidationError>(
 animalId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimalHealthEventsApiEventsAnimalAnimalIdHealthGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Animal Health Events
 */

export function useGetAnimalHealthEventsApiEventsAnimalAnimalIdHealthGet<TData = Awaited<ReturnType<typeof getAnimalHealthEventsApiEventsAnimalAnimalIdHealthGet>>, TError = HTTPValidationError>(
 animalId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimalHealthEventsApiEventsAnimalAnimalIdHealthGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAnimalHealthEventsApiEventsAnimalAnimalIdHealthGetQueryOptions(animalId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get medication history for an animal
 * @summary Get Animal Medication History
 */
export const getAnimalMedicationHistoryApiEventsAnimalAnimalIdMedicationGet = (
    animalId: number,
 signal?: AbortSignal
) => {
      
      
      return apiClient<Event[]>(
      {url: `/api/events/animal/${animalId}/medication`, method: 'GET', signal
    },
      );
    }
  

export const getGetAnimalMedicationHistoryApiEventsAnimalAnimalIdMedicationGetQueryKey = (animalId?: number,) => {
    return [`/api/events/animal/${animalId}/medication`] as const;
    }

    
export const getGetAnimalMedicationHistoryApiEventsAnimalAnimalIdMedicationGetQueryOptions = <TData = Awaited<ReturnType<typeof getAnimalMedicationHistoryApiEventsAnimalAnimalIdMedicationGet>>, TError = HTTPValidationError>(animalId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimalMedicationHistoryApiEventsAnimalAnimalIdMedicationGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimalMedicationHistoryApiEventsAnimalAnimalIdMedicationGetQueryKey(animalId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimalMedicationHistoryApiEventsAnimalAnimalIdMedicationGet>>> = ({ signal }) => getAnimalMedicationHistoryApiEventsAnimalAnimalIdMedicationGet(animalId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(animalId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAnimalMedicationHistoryApiEventsAnimalAnimalIdMedicationGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAnimalMedicationHistoryApiEventsAnimalAnimalIdMedicationGetQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimalMedicationHistoryApiEventsAnimalAnimalIdMedicationGet>>>
export type GetAnimalMedicationHistoryApiEventsAnimalAnimalIdMedicationGetQueryError = HTTPValidationError


export function useGetAnimalMedicationHistoryApiEventsAnimalAnimalIdMedicationGet<TData = Awaited<ReturnType<typeof getAnimalMedicationHistoryApiEventsAnimalAnimalIdMedicationGet>>, TError = HTTPValidationError>(
 animalId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimalMedicationHistoryApiEventsAnimalAnimalIdMedicationGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAnimalMedicationHistoryApiEventsAnimalAnimalIdMedicationGet>>,
          TError,
          Awaited<ReturnType<typeof getAnimalMedicationHistoryApiEventsAnimalAnimalIdMedicationGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAnimalMedicationHistoryApiEventsAnimalAnimalIdMedicationGet<TData = Awaited<ReturnType<typeof getAnimalMedicationHistoryApiEventsAnimalAnimalIdMedicationGet>>, TError = HTTPValidationError>(
 animalId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimalMedicationHistoryApiEventsAnimalAnimalIdMedicationGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAnimalMedicationHistoryApiEventsAnimalAnimalIdMedicationGet>>,
          TError,
          Awaited<ReturnType<typeof getAnimalMedicationHistoryApiEventsAnimalAnimalIdMedicationGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAnimalMedicationHistoryApiEventsAnimalAnimalIdMedicationGet<TData = Awaited<ReturnType<typeof getAnimalMedicationHistoryApiEventsAnimalAnimalIdMedicationGet>>, TError = HTTPValidationError>(
 animalId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimalMedicationHistoryApiEventsAnimalAnimalIdMedicationGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Animal Medication History
 */

export function useGetAnimalMedicationHistoryApiEventsAnimalAnimalIdMedicationGet<TData = Awaited<ReturnType<typeof getAnimalMedicationHistoryApiEventsAnimalAnimalIdMedicationGet>>, TError = HTTPValidationError>(
 animalId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimalMedicationHistoryApiEventsAnimalAnimalIdMedicationGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAnimalMedicationHistoryApiEventsAnimalAnimalIdMedicationGetQueryOptions(animalId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get all expenses with optional filtering
 * @summary List Expenses
 */
export const listExpensesApiExpensesGet = (
    params?: ListExpensesApiExpensesGetParams,
 signal?: AbortSignal
) => {
      
      
      return apiClient<ExpenseResponse[]>(
      {url: `/api/expenses`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getListExpensesApiExpensesGetQueryKey = (params?: ListExpensesApiExpensesGetParams,) => {
    return [`/api/expenses`, ...(params ? [params]: [])] as const;
    }

    
export const getListExpensesApiExpensesGetQueryOptions = <TData = Awaited<ReturnType<typeof listExpensesApiExpensesGet>>, TError = HTTPValidationError>(params?: ListExpensesApiExpensesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listExpensesApiExpensesGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListExpensesApiExpensesGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listExpensesApiExpensesGet>>> = ({ signal }) => listExpensesApiExpensesGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listExpensesApiExpensesGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListExpensesApiExpensesGetQueryResult = NonNullable<Awaited<ReturnType<typeof listExpensesApiExpensesGet>>>
export type ListExpensesApiExpensesGetQueryError = HTTPValidationError


export function useListExpensesApiExpensesGet<TData = Awaited<ReturnType<typeof listExpensesApiExpensesGet>>, TError = HTTPValidationError>(
 params: undefined |  ListExpensesApiExpensesGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listExpensesApiExpensesGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listExpensesApiExpensesGet>>,
          TError,
          Awaited<ReturnType<typeof listExpensesApiExpensesGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListExpensesApiExpensesGet<TData = Awaited<ReturnType<typeof listExpensesApiExpensesGet>>, TError = HTTPValidationError>(
 params?: ListExpensesApiExpensesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listExpensesApiExpensesGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listExpensesApiExpensesGet>>,
          TError,
          Awaited<ReturnType<typeof listExpensesApiExpensesGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListExpensesApiExpensesGet<TData = Awaited<ReturnType<typeof listExpensesApiExpensesGet>>, TError = HTTPValidationError>(
 params?: ListExpensesApiExpensesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listExpensesApiExpensesGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Expenses
 */

export function useListExpensesApiExpensesGet<TData = Awaited<ReturnType<typeof listExpensesApiExpensesGet>>, TError = HTTPValidationError>(
 params?: ListExpensesApiExpensesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listExpensesApiExpensesGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListExpensesApiExpensesGetQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new expense with optional line items
 * @summary Create Expense
 */
export const createExpenseApiExpensesPost = (
    expenseCreate: ExpenseCreate,
 signal?: AbortSignal
) => {
      
      
      return apiClient<ExpenseResponse>(
      {url: `/api/expenses`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: expenseCreate, signal
    },
      );
    }
  


export const getCreateExpenseApiExpensesPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createExpenseApiExpensesPost>>, TError,{data: ExpenseCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createExpenseApiExpensesPost>>, TError,{data: ExpenseCreate}, TContext> => {

const mutationKey = ['createExpenseApiExpensesPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createExpenseApiExpensesPost>>, {data: ExpenseCreate}> = (props) => {
          const {data} = props ?? {};

          return  createExpenseApiExpensesPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateExpenseApiExpensesPostMutationResult = NonNullable<Awaited<ReturnType<typeof createExpenseApiExpensesPost>>>
    export type CreateExpenseApiExpensesPostMutationBody = ExpenseCreate
    export type CreateExpenseApiExpensesPostMutationError = HTTPValidationError

    /**
 * @summary Create Expense
 */
export const useCreateExpenseApiExpensesPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createExpenseApiExpensesPost>>, TError,{data: ExpenseCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createExpenseApiExpensesPost>>,
        TError,
        {data: ExpenseCreate},
        TContext
      > => {

      const mutationOptions = getCreateExpenseApiExpensesPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get a specific expense by ID
 * @summary Get Expense
 */
export const getExpenseApiExpensesExpenseIdGet = (
    expenseId: number,
 signal?: AbortSignal
) => {
      
      
      return apiClient<ExpenseResponse>(
      {url: `/api/expenses/${expenseId}`, method: 'GET', signal
    },
      );
    }
  

export const getGetExpenseApiExpensesExpenseIdGetQueryKey = (expenseId?: number,) => {
    return [`/api/expenses/${expenseId}`] as const;
    }

    
export const getGetExpenseApiExpensesExpenseIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getExpenseApiExpensesExpenseIdGet>>, TError = HTTPValidationError>(expenseId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenseApiExpensesExpenseIdGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetExpenseApiExpensesExpenseIdGetQueryKey(expenseId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getExpenseApiExpensesExpenseIdGet>>> = ({ signal }) => getExpenseApiExpensesExpenseIdGet(expenseId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(expenseId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getExpenseApiExpensesExpenseIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetExpenseApiExpensesExpenseIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getExpenseApiExpensesExpenseIdGet>>>
export type GetExpenseApiExpensesExpenseIdGetQueryError = HTTPValidationError


export function useGetExpenseApiExpensesExpenseIdGet<TData = Awaited<ReturnType<typeof getExpenseApiExpensesExpenseIdGet>>, TError = HTTPValidationError>(
 expenseId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenseApiExpensesExpenseIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExpenseApiExpensesExpenseIdGet>>,
          TError,
          Awaited<ReturnType<typeof getExpenseApiExpensesExpenseIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetExpenseApiExpensesExpenseIdGet<TData = Awaited<ReturnType<typeof getExpenseApiExpensesExpenseIdGet>>, TError = HTTPValidationError>(
 expenseId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenseApiExpensesExpenseIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExpenseApiExpensesExpenseIdGet>>,
          TError,
          Awaited<ReturnType<typeof getExpenseApiExpensesExpenseIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetExpenseApiExpensesExpenseIdGet<TData = Awaited<ReturnType<typeof getExpenseApiExpensesExpenseIdGet>>, TError = HTTPValidationError>(
 expenseId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenseApiExpensesExpenseIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Expense
 */

export function useGetExpenseApiExpensesExpenseIdGet<TData = Awaited<ReturnType<typeof getExpenseApiExpensesExpenseIdGet>>, TError = HTTPValidationError>(
 expenseId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenseApiExpensesExpenseIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetExpenseApiExpensesExpenseIdGetQueryOptions(expenseId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an existing expense and its line items
 * @summary Update Expense
 */
export const updateExpenseApiExpensesExpenseIdPut = (
    expenseId: number,
    expenseUpdate: ExpenseUpdate,
 ) => {
      
      
      return apiClient<ExpenseResponse>(
      {url: `/api/expenses/${expenseId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: expenseUpdate
    },
      );
    }
  


export const getUpdateExpenseApiExpensesExpenseIdPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateExpenseApiExpensesExpenseIdPut>>, TError,{expenseId: number;data: ExpenseUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateExpenseApiExpensesExpenseIdPut>>, TError,{expenseId: number;data: ExpenseUpdate}, TContext> => {

const mutationKey = ['updateExpenseApiExpensesExpenseIdPut'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateExpenseApiExpensesExpenseIdPut>>, {expenseId: number;data: ExpenseUpdate}> = (props) => {
          const {expenseId,data} = props ?? {};

          return  updateExpenseApiExpensesExpenseIdPut(expenseId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateExpenseApiExpensesExpenseIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateExpenseApiExpensesExpenseIdPut>>>
    export type UpdateExpenseApiExpensesExpenseIdPutMutationBody = ExpenseUpdate
    export type UpdateExpenseApiExpensesExpenseIdPutMutationError = HTTPValidationError

    /**
 * @summary Update Expense
 */
export const useUpdateExpenseApiExpensesExpenseIdPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateExpenseApiExpensesExpenseIdPut>>, TError,{expenseId: number;data: ExpenseUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateExpenseApiExpensesExpenseIdPut>>,
        TError,
        {expenseId: number;data: ExpenseUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateExpenseApiExpensesExpenseIdPutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete an expense
 * @summary Delete Expense
 */
export const deleteExpenseApiExpensesExpenseIdDelete = (
    expenseId: number,
 ) => {
      
      
      return apiClient<unknown>(
      {url: `/api/expenses/${expenseId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteExpenseApiExpensesExpenseIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteExpenseApiExpensesExpenseIdDelete>>, TError,{expenseId: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteExpenseApiExpensesExpenseIdDelete>>, TError,{expenseId: number}, TContext> => {

const mutationKey = ['deleteExpenseApiExpensesExpenseIdDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteExpenseApiExpensesExpenseIdDelete>>, {expenseId: number}> = (props) => {
          const {expenseId} = props ?? {};

          return  deleteExpenseApiExpensesExpenseIdDelete(expenseId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteExpenseApiExpensesExpenseIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteExpenseApiExpensesExpenseIdDelete>>>
    
    export type DeleteExpenseApiExpensesExpenseIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Expense
 */
export const useDeleteExpenseApiExpensesExpenseIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteExpenseApiExpensesExpenseIdDelete>>, TError,{expenseId: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteExpenseApiExpensesExpenseIdDelete>>,
        TError,
        {expenseId: number},
        TContext
      > => {

      const mutationOptions = getDeleteExpenseApiExpensesExpenseIdDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get all vendors with optional filtering
 * @summary List Vendors
 */
export const listVendorsApiVendorsGet = (
    params?: ListVendorsApiVendorsGetParams,
 signal?: AbortSignal
) => {
      
      
      return apiClient<VendorResponse[]>(
      {url: `/api/vendors`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getListVendorsApiVendorsGetQueryKey = (params?: ListVendorsApiVendorsGetParams,) => {
    return [`/api/vendors`, ...(params ? [params]: [])] as const;
    }

    
export const getListVendorsApiVendorsGetQueryOptions = <TData = Awaited<ReturnType<typeof listVendorsApiVendorsGet>>, TError = HTTPValidationError>(params?: ListVendorsApiVendorsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listVendorsApiVendorsGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListVendorsApiVendorsGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listVendorsApiVendorsGet>>> = ({ signal }) => listVendorsApiVendorsGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listVendorsApiVendorsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListVendorsApiVendorsGetQueryResult = NonNullable<Awaited<ReturnType<typeof listVendorsApiVendorsGet>>>
export type ListVendorsApiVendorsGetQueryError = HTTPValidationError


export function useListVendorsApiVendorsGet<TData = Awaited<ReturnType<typeof listVendorsApiVendorsGet>>, TError = HTTPValidationError>(
 params: undefined |  ListVendorsApiVendorsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listVendorsApiVendorsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listVendorsApiVendorsGet>>,
          TError,
          Awaited<ReturnType<typeof listVendorsApiVendorsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListVendorsApiVendorsGet<TData = Awaited<ReturnType<typeof listVendorsApiVendorsGet>>, TError = HTTPValidationError>(
 params?: ListVendorsApiVendorsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listVendorsApiVendorsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listVendorsApiVendorsGet>>,
          TError,
          Awaited<ReturnType<typeof listVendorsApiVendorsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListVendorsApiVendorsGet<TData = Awaited<ReturnType<typeof listVendorsApiVendorsGet>>, TError = HTTPValidationError>(
 params?: ListVendorsApiVendorsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listVendorsApiVendorsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Vendors
 */

export function useListVendorsApiVendorsGet<TData = Awaited<ReturnType<typeof listVendorsApiVendorsGet>>, TError = HTTPValidationError>(
 params?: ListVendorsApiVendorsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listVendorsApiVendorsGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListVendorsApiVendorsGetQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new vendor
 * @summary Create Vendor
 */
export const createVendorApiVendorsPost = (
    vendorCreate: VendorCreate,
 signal?: AbortSignal
) => {
      
      
      return apiClient<VendorResponse>(
      {url: `/api/vendors`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: vendorCreate, signal
    },
      );
    }
  


export const getCreateVendorApiVendorsPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createVendorApiVendorsPost>>, TError,{data: VendorCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createVendorApiVendorsPost>>, TError,{data: VendorCreate}, TContext> => {

const mutationKey = ['createVendorApiVendorsPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createVendorApiVendorsPost>>, {data: VendorCreate}> = (props) => {
          const {data} = props ?? {};

          return  createVendorApiVendorsPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateVendorApiVendorsPostMutationResult = NonNullable<Awaited<ReturnType<typeof createVendorApiVendorsPost>>>
    export type CreateVendorApiVendorsPostMutationBody = VendorCreate
    export type CreateVendorApiVendorsPostMutationError = HTTPValidationError

    /**
 * @summary Create Vendor
 */
export const useCreateVendorApiVendorsPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createVendorApiVendorsPost>>, TError,{data: VendorCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createVendorApiVendorsPost>>,
        TError,
        {data: VendorCreate},
        TContext
      > => {

      const mutationOptions = getCreateVendorApiVendorsPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get a specific vendor by ID
 * @summary Get Vendor
 */
export const getVendorApiVendorsVendorIdGet = (
    vendorId: number,
 signal?: AbortSignal
) => {
      
      
      return apiClient<VendorResponse>(
      {url: `/api/vendors/${vendorId}`, method: 'GET', signal
    },
      );
    }
  

export const getGetVendorApiVendorsVendorIdGetQueryKey = (vendorId?: number,) => {
    return [`/api/vendors/${vendorId}`] as const;
    }

    
export const getGetVendorApiVendorsVendorIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getVendorApiVendorsVendorIdGet>>, TError = HTTPValidationError>(vendorId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVendorApiVendorsVendorIdGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetVendorApiVendorsVendorIdGetQueryKey(vendorId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getVendorApiVendorsVendorIdGet>>> = ({ signal }) => getVendorApiVendorsVendorIdGet(vendorId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(vendorId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getVendorApiVendorsVendorIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetVendorApiVendorsVendorIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getVendorApiVendorsVendorIdGet>>>
export type GetVendorApiVendorsVendorIdGetQueryError = HTTPValidationError


export function useGetVendorApiVendorsVendorIdGet<TData = Awaited<ReturnType<typeof getVendorApiVendorsVendorIdGet>>, TError = HTTPValidationError>(
 vendorId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVendorApiVendorsVendorIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVendorApiVendorsVendorIdGet>>,
          TError,
          Awaited<ReturnType<typeof getVendorApiVendorsVendorIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetVendorApiVendorsVendorIdGet<TData = Awaited<ReturnType<typeof getVendorApiVendorsVendorIdGet>>, TError = HTTPValidationError>(
 vendorId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVendorApiVendorsVendorIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVendorApiVendorsVendorIdGet>>,
          TError,
          Awaited<ReturnType<typeof getVendorApiVendorsVendorIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetVendorApiVendorsVendorIdGet<TData = Awaited<ReturnType<typeof getVendorApiVendorsVendorIdGet>>, TError = HTTPValidationError>(
 vendorId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVendorApiVendorsVendorIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Vendor
 */

export function useGetVendorApiVendorsVendorIdGet<TData = Awaited<ReturnType<typeof getVendorApiVendorsVendorIdGet>>, TError = HTTPValidationError>(
 vendorId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVendorApiVendorsVendorIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetVendorApiVendorsVendorIdGetQueryOptions(vendorId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an existing vendor
 * @summary Update Vendor
 */
export const updateVendorApiVendorsVendorIdPut = (
    vendorId: number,
    vendorUpdate: VendorUpdate,
 ) => {
      
      
      return apiClient<VendorResponse>(
      {url: `/api/vendors/${vendorId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: vendorUpdate
    },
      );
    }
  


export const getUpdateVendorApiVendorsVendorIdPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateVendorApiVendorsVendorIdPut>>, TError,{vendorId: number;data: VendorUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateVendorApiVendorsVendorIdPut>>, TError,{vendorId: number;data: VendorUpdate}, TContext> => {

const mutationKey = ['updateVendorApiVendorsVendorIdPut'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateVendorApiVendorsVendorIdPut>>, {vendorId: number;data: VendorUpdate}> = (props) => {
          const {vendorId,data} = props ?? {};

          return  updateVendorApiVendorsVendorIdPut(vendorId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateVendorApiVendorsVendorIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateVendorApiVendorsVendorIdPut>>>
    export type UpdateVendorApiVendorsVendorIdPutMutationBody = VendorUpdate
    export type UpdateVendorApiVendorsVendorIdPutMutationError = HTTPValidationError

    /**
 * @summary Update Vendor
 */
export const useUpdateVendorApiVendorsVendorIdPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateVendorApiVendorsVendorIdPut>>, TError,{vendorId: number;data: VendorUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateVendorApiVendorsVendorIdPut>>,
        TError,
        {vendorId: number;data: VendorUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateVendorApiVendorsVendorIdPutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a vendor
 * @summary Delete Vendor
 */
export const deleteVendorApiVendorsVendorIdDelete = (
    vendorId: number,
 ) => {
      
      
      return apiClient<unknown>(
      {url: `/api/vendors/${vendorId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteVendorApiVendorsVendorIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteVendorApiVendorsVendorIdDelete>>, TError,{vendorId: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteVendorApiVendorsVendorIdDelete>>, TError,{vendorId: number}, TContext> => {

const mutationKey = ['deleteVendorApiVendorsVendorIdDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteVendorApiVendorsVendorIdDelete>>, {vendorId: number}> = (props) => {
          const {vendorId} = props ?? {};

          return  deleteVendorApiVendorsVendorIdDelete(vendorId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteVendorApiVendorsVendorIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteVendorApiVendorsVendorIdDelete>>>
    
    export type DeleteVendorApiVendorsVendorIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Vendor
 */
export const useDeleteVendorApiVendorsVendorIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteVendorApiVendorsVendorIdDelete>>, TError,{vendorId: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteVendorApiVendorsVendorIdDelete>>,
        TError,
        {vendorId: number},
        TContext
      > => {

      const mutationOptions = getDeleteVendorApiVendorsVendorIdDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Upload a receipt image or PDF for OCR processing
 * @summary Upload Receipt
 */
export const uploadReceiptApiReceiptsUploadPost = (
    bodyUploadReceiptApiReceiptsUploadPost: BodyUploadReceiptApiReceiptsUploadPost,
 signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append(`file`, bodyUploadReceiptApiReceiptsUploadPost.file)

      return apiClient<ReceiptResponse>(
      {url: `/api/receipts/upload`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      );
    }
  


export const getUploadReceiptApiReceiptsUploadPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadReceiptApiReceiptsUploadPost>>, TError,{data: BodyUploadReceiptApiReceiptsUploadPost}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof uploadReceiptApiReceiptsUploadPost>>, TError,{data: BodyUploadReceiptApiReceiptsUploadPost}, TContext> => {

const mutationKey = ['uploadReceiptApiReceiptsUploadPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof uploadReceiptApiReceiptsUploadPost>>, {data: BodyUploadReceiptApiReceiptsUploadPost}> = (props) => {
          const {data} = props ?? {};

          return  uploadReceiptApiReceiptsUploadPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UploadReceiptApiReceiptsUploadPostMutationResult = NonNullable<Awaited<ReturnType<typeof uploadReceiptApiReceiptsUploadPost>>>
    export type UploadReceiptApiReceiptsUploadPostMutationBody = BodyUploadReceiptApiReceiptsUploadPost
    export type UploadReceiptApiReceiptsUploadPostMutationError = HTTPValidationError

    /**
 * @summary Upload Receipt
 */
export const useUploadReceiptApiReceiptsUploadPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadReceiptApiReceiptsUploadPost>>, TError,{data: BodyUploadReceiptApiReceiptsUploadPost}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof uploadReceiptApiReceiptsUploadPost>>,
        TError,
        {data: BodyUploadReceiptApiReceiptsUploadPost},
        TContext
      > => {

      const mutationOptions = getUploadReceiptApiReceiptsUploadPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Process a receipt with OCR and extract structured data (async with Celery)
 * @summary Process Receipt
 */
export const processReceiptApiReceiptsReceiptIdProcessPost = (
    receiptId: number,
 signal?: AbortSignal
) => {
      
      
      return apiClient<unknown>(
      {url: `/api/receipts/${receiptId}/process`, method: 'POST', signal
    },
      );
    }
  


export const getProcessReceiptApiReceiptsReceiptIdProcessPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof processReceiptApiReceiptsReceiptIdProcessPost>>, TError,{receiptId: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof processReceiptApiReceiptsReceiptIdProcessPost>>, TError,{receiptId: number}, TContext> => {

const mutationKey = ['processReceiptApiReceiptsReceiptIdProcessPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof processReceiptApiReceiptsReceiptIdProcessPost>>, {receiptId: number}> = (props) => {
          const {receiptId} = props ?? {};

          return  processReceiptApiReceiptsReceiptIdProcessPost(receiptId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ProcessReceiptApiReceiptsReceiptIdProcessPostMutationResult = NonNullable<Awaited<ReturnType<typeof processReceiptApiReceiptsReceiptIdProcessPost>>>
    
    export type ProcessReceiptApiReceiptsReceiptIdProcessPostMutationError = HTTPValidationError

    /**
 * @summary Process Receipt
 */
export const useProcessReceiptApiReceiptsReceiptIdProcessPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof processReceiptApiReceiptsReceiptIdProcessPost>>, TError,{receiptId: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof processReceiptApiReceiptsReceiptIdProcessPost>>,
        TError,
        {receiptId: number},
        TContext
      > => {

      const mutationOptions = getProcessReceiptApiReceiptsReceiptIdProcessPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Check the status of an OCR processing task
 * @summary Get Task Status
 */
export const getTaskStatusApiReceiptsTaskTaskIdGet = (
    taskId: string,
 signal?: AbortSignal
) => {
      
      
      return apiClient<unknown>(
      {url: `/api/receipts/task/${taskId}`, method: 'GET', signal
    },
      );
    }
  

export const getGetTaskStatusApiReceiptsTaskTaskIdGetQueryKey = (taskId?: string,) => {
    return [`/api/receipts/task/${taskId}`] as const;
    }

    
export const getGetTaskStatusApiReceiptsTaskTaskIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getTaskStatusApiReceiptsTaskTaskIdGet>>, TError = HTTPValidationError>(taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTaskStatusApiReceiptsTaskTaskIdGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTaskStatusApiReceiptsTaskTaskIdGetQueryKey(taskId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTaskStatusApiReceiptsTaskTaskIdGet>>> = ({ signal }) => getTaskStatusApiReceiptsTaskTaskIdGet(taskId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(taskId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTaskStatusApiReceiptsTaskTaskIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTaskStatusApiReceiptsTaskTaskIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getTaskStatusApiReceiptsTaskTaskIdGet>>>
export type GetTaskStatusApiReceiptsTaskTaskIdGetQueryError = HTTPValidationError


export function useGetTaskStatusApiReceiptsTaskTaskIdGet<TData = Awaited<ReturnType<typeof getTaskStatusApiReceiptsTaskTaskIdGet>>, TError = HTTPValidationError>(
 taskId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTaskStatusApiReceiptsTaskTaskIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTaskStatusApiReceiptsTaskTaskIdGet>>,
          TError,
          Awaited<ReturnType<typeof getTaskStatusApiReceiptsTaskTaskIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTaskStatusApiReceiptsTaskTaskIdGet<TData = Awaited<ReturnType<typeof getTaskStatusApiReceiptsTaskTaskIdGet>>, TError = HTTPValidationError>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTaskStatusApiReceiptsTaskTaskIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTaskStatusApiReceiptsTaskTaskIdGet>>,
          TError,
          Awaited<ReturnType<typeof getTaskStatusApiReceiptsTaskTaskIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTaskStatusApiReceiptsTaskTaskIdGet<TData = Awaited<ReturnType<typeof getTaskStatusApiReceiptsTaskTaskIdGet>>, TError = HTTPValidationError>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTaskStatusApiReceiptsTaskTaskIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Task Status
 */

export function useGetTaskStatusApiReceiptsTaskTaskIdGet<TData = Awaited<ReturnType<typeof getTaskStatusApiReceiptsTaskTaskIdGet>>, TError = HTTPValidationError>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTaskStatusApiReceiptsTaskTaskIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTaskStatusApiReceiptsTaskTaskIdGetQueryOptions(taskId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get all receipts
 * @summary Get Receipts
 */
export const getReceiptsApiReceiptsGet = (
    params?: GetReceiptsApiReceiptsGetParams,
 signal?: AbortSignal
) => {
      
      
      return apiClient<ReceiptResponse[]>(
      {url: `/api/receipts/`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetReceiptsApiReceiptsGetQueryKey = (params?: GetReceiptsApiReceiptsGetParams,) => {
    return [`/api/receipts/`, ...(params ? [params]: [])] as const;
    }

    
export const getGetReceiptsApiReceiptsGetQueryOptions = <TData = Awaited<ReturnType<typeof getReceiptsApiReceiptsGet>>, TError = HTTPValidationError>(params?: GetReceiptsApiReceiptsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReceiptsApiReceiptsGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetReceiptsApiReceiptsGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getReceiptsApiReceiptsGet>>> = ({ signal }) => getReceiptsApiReceiptsGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getReceiptsApiReceiptsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetReceiptsApiReceiptsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getReceiptsApiReceiptsGet>>>
export type GetReceiptsApiReceiptsGetQueryError = HTTPValidationError


export function useGetReceiptsApiReceiptsGet<TData = Awaited<ReturnType<typeof getReceiptsApiReceiptsGet>>, TError = HTTPValidationError>(
 params: undefined |  GetReceiptsApiReceiptsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReceiptsApiReceiptsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReceiptsApiReceiptsGet>>,
          TError,
          Awaited<ReturnType<typeof getReceiptsApiReceiptsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetReceiptsApiReceiptsGet<TData = Awaited<ReturnType<typeof getReceiptsApiReceiptsGet>>, TError = HTTPValidationError>(
 params?: GetReceiptsApiReceiptsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReceiptsApiReceiptsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReceiptsApiReceiptsGet>>,
          TError,
          Awaited<ReturnType<typeof getReceiptsApiReceiptsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetReceiptsApiReceiptsGet<TData = Awaited<ReturnType<typeof getReceiptsApiReceiptsGet>>, TError = HTTPValidationError>(
 params?: GetReceiptsApiReceiptsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReceiptsApiReceiptsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Receipts
 */

export function useGetReceiptsApiReceiptsGet<TData = Awaited<ReturnType<typeof getReceiptsApiReceiptsGet>>, TError = HTTPValidationError>(
 params?: GetReceiptsApiReceiptsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReceiptsApiReceiptsGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetReceiptsApiReceiptsGetQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get a specific receipt
 * @summary Get Receipt
 */
export const getReceiptApiReceiptsReceiptIdGet = (
    receiptId: number,
 signal?: AbortSignal
) => {
      
      
      return apiClient<ReceiptResponse>(
      {url: `/api/receipts/${receiptId}`, method: 'GET', signal
    },
      );
    }
  

export const getGetReceiptApiReceiptsReceiptIdGetQueryKey = (receiptId?: number,) => {
    return [`/api/receipts/${receiptId}`] as const;
    }

    
export const getGetReceiptApiReceiptsReceiptIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getReceiptApiReceiptsReceiptIdGet>>, TError = HTTPValidationError>(receiptId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReceiptApiReceiptsReceiptIdGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetReceiptApiReceiptsReceiptIdGetQueryKey(receiptId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getReceiptApiReceiptsReceiptIdGet>>> = ({ signal }) => getReceiptApiReceiptsReceiptIdGet(receiptId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(receiptId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getReceiptApiReceiptsReceiptIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetReceiptApiReceiptsReceiptIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getReceiptApiReceiptsReceiptIdGet>>>
export type GetReceiptApiReceiptsReceiptIdGetQueryError = HTTPValidationError


export function useGetReceiptApiReceiptsReceiptIdGet<TData = Awaited<ReturnType<typeof getReceiptApiReceiptsReceiptIdGet>>, TError = HTTPValidationError>(
 receiptId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReceiptApiReceiptsReceiptIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReceiptApiReceiptsReceiptIdGet>>,
          TError,
          Awaited<ReturnType<typeof getReceiptApiReceiptsReceiptIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetReceiptApiReceiptsReceiptIdGet<TData = Awaited<ReturnType<typeof getReceiptApiReceiptsReceiptIdGet>>, TError = HTTPValidationError>(
 receiptId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReceiptApiReceiptsReceiptIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReceiptApiReceiptsReceiptIdGet>>,
          TError,
          Awaited<ReturnType<typeof getReceiptApiReceiptsReceiptIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetReceiptApiReceiptsReceiptIdGet<TData = Awaited<ReturnType<typeof getReceiptApiReceiptsReceiptIdGet>>, TError = HTTPValidationError>(
 receiptId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReceiptApiReceiptsReceiptIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Receipt
 */

export function useGetReceiptApiReceiptsReceiptIdGet<TData = Awaited<ReturnType<typeof getReceiptApiReceiptsReceiptIdGet>>, TError = HTTPValidationError>(
 receiptId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReceiptApiReceiptsReceiptIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetReceiptApiReceiptsReceiptIdGetQueryOptions(receiptId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Delete a receipt and its file
 * @summary Delete Receipt
 */
export const deleteReceiptApiReceiptsReceiptIdDelete = (
    receiptId: number,
 ) => {
      
      
      return apiClient<unknown>(
      {url: `/api/receipts/${receiptId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteReceiptApiReceiptsReceiptIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteReceiptApiReceiptsReceiptIdDelete>>, TError,{receiptId: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteReceiptApiReceiptsReceiptIdDelete>>, TError,{receiptId: number}, TContext> => {

const mutationKey = ['deleteReceiptApiReceiptsReceiptIdDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteReceiptApiReceiptsReceiptIdDelete>>, {receiptId: number}> = (props) => {
          const {receiptId} = props ?? {};

          return  deleteReceiptApiReceiptsReceiptIdDelete(receiptId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteReceiptApiReceiptsReceiptIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteReceiptApiReceiptsReceiptIdDelete>>>
    
    export type DeleteReceiptApiReceiptsReceiptIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Receipt
 */
export const useDeleteReceiptApiReceiptsReceiptIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteReceiptApiReceiptsReceiptIdDelete>>, TError,{receiptId: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteReceiptApiReceiptsReceiptIdDelete>>,
        TError,
        {receiptId: number},
        TContext
      > => {

      const mutationOptions = getDeleteReceiptApiReceiptsReceiptIdDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get all locations
 * @summary Read Locations
 */
export const readLocationsApiLocationsGet = (
    params?: ReadLocationsApiLocationsGetParams,
 signal?: AbortSignal
) => {
      
      
      return apiClient<Location[]>(
      {url: `/api/locations`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getReadLocationsApiLocationsGetQueryKey = (params?: ReadLocationsApiLocationsGetParams,) => {
    return [`/api/locations`, ...(params ? [params]: [])] as const;
    }

    
export const getReadLocationsApiLocationsGetQueryOptions = <TData = Awaited<ReturnType<typeof readLocationsApiLocationsGet>>, TError = HTTPValidationError>(params?: ReadLocationsApiLocationsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readLocationsApiLocationsGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadLocationsApiLocationsGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readLocationsApiLocationsGet>>> = ({ signal }) => readLocationsApiLocationsGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readLocationsApiLocationsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadLocationsApiLocationsGetQueryResult = NonNullable<Awaited<ReturnType<typeof readLocationsApiLocationsGet>>>
export type ReadLocationsApiLocationsGetQueryError = HTTPValidationError


export function useReadLocationsApiLocationsGet<TData = Awaited<ReturnType<typeof readLocationsApiLocationsGet>>, TError = HTTPValidationError>(
 params: undefined |  ReadLocationsApiLocationsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readLocationsApiLocationsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readLocationsApiLocationsGet>>,
          TError,
          Awaited<ReturnType<typeof readLocationsApiLocationsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadLocationsApiLocationsGet<TData = Awaited<ReturnType<typeof readLocationsApiLocationsGet>>, TError = HTTPValidationError>(
 params?: ReadLocationsApiLocationsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readLocationsApiLocationsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readLocationsApiLocationsGet>>,
          TError,
          Awaited<ReturnType<typeof readLocationsApiLocationsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadLocationsApiLocationsGet<TData = Awaited<ReturnType<typeof readLocationsApiLocationsGet>>, TError = HTTPValidationError>(
 params?: ReadLocationsApiLocationsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readLocationsApiLocationsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Locations
 */

export function useReadLocationsApiLocationsGet<TData = Awaited<ReturnType<typeof readLocationsApiLocationsGet>>, TError = HTTPValidationError>(
 params?: ReadLocationsApiLocationsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readLocationsApiLocationsGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadLocationsApiLocationsGetQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new location
 * @summary Create Location
 */
export const createLocationApiLocationsPost = (
    locationCreate: LocationCreate,
 signal?: AbortSignal
) => {
      
      
      return apiClient<Location>(
      {url: `/api/locations`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: locationCreate, signal
    },
      );
    }
  


export const getCreateLocationApiLocationsPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createLocationApiLocationsPost>>, TError,{data: LocationCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createLocationApiLocationsPost>>, TError,{data: LocationCreate}, TContext> => {

const mutationKey = ['createLocationApiLocationsPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createLocationApiLocationsPost>>, {data: LocationCreate}> = (props) => {
          const {data} = props ?? {};

          return  createLocationApiLocationsPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateLocationApiLocationsPostMutationResult = NonNullable<Awaited<ReturnType<typeof createLocationApiLocationsPost>>>
    export type CreateLocationApiLocationsPostMutationBody = LocationCreate
    export type CreateLocationApiLocationsPostMutationError = HTTPValidationError

    /**
 * @summary Create Location
 */
export const useCreateLocationApiLocationsPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createLocationApiLocationsPost>>, TError,{data: LocationCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createLocationApiLocationsPost>>,
        TError,
        {data: LocationCreate},
        TContext
      > => {

      const mutationOptions = getCreateLocationApiLocationsPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Search locations by name, paddock name, or address
 * @summary Search Locations
 */
export const searchLocationsApiLocationsSearchGet = (
    params: SearchLocationsApiLocationsSearchGetParams,
 signal?: AbortSignal
) => {
      
      
      return apiClient<unknown>(
      {url: `/api/locations/search`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getSearchLocationsApiLocationsSearchGetQueryKey = (params?: SearchLocationsApiLocationsSearchGetParams,) => {
    return [`/api/locations/search`, ...(params ? [params]: [])] as const;
    }

    
export const getSearchLocationsApiLocationsSearchGetQueryOptions = <TData = Awaited<ReturnType<typeof searchLocationsApiLocationsSearchGet>>, TError = HTTPValidationError>(params: SearchLocationsApiLocationsSearchGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchLocationsApiLocationsSearchGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchLocationsApiLocationsSearchGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchLocationsApiLocationsSearchGet>>> = ({ signal }) => searchLocationsApiLocationsSearchGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchLocationsApiLocationsSearchGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SearchLocationsApiLocationsSearchGetQueryResult = NonNullable<Awaited<ReturnType<typeof searchLocationsApiLocationsSearchGet>>>
export type SearchLocationsApiLocationsSearchGetQueryError = HTTPValidationError


export function useSearchLocationsApiLocationsSearchGet<TData = Awaited<ReturnType<typeof searchLocationsApiLocationsSearchGet>>, TError = HTTPValidationError>(
 params: SearchLocationsApiLocationsSearchGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchLocationsApiLocationsSearchGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchLocationsApiLocationsSearchGet>>,
          TError,
          Awaited<ReturnType<typeof searchLocationsApiLocationsSearchGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchLocationsApiLocationsSearchGet<TData = Awaited<ReturnType<typeof searchLocationsApiLocationsSearchGet>>, TError = HTTPValidationError>(
 params: SearchLocationsApiLocationsSearchGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchLocationsApiLocationsSearchGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchLocationsApiLocationsSearchGet>>,
          TError,
          Awaited<ReturnType<typeof searchLocationsApiLocationsSearchGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchLocationsApiLocationsSearchGet<TData = Awaited<ReturnType<typeof searchLocationsApiLocationsSearchGet>>, TError = HTTPValidationError>(
 params: SearchLocationsApiLocationsSearchGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchLocationsApiLocationsSearchGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Search Locations
 */

export function useSearchLocationsApiLocationsSearchGet<TData = Awaited<ReturnType<typeof searchLocationsApiLocationsSearchGet>>, TError = HTTPValidationError>(
 params: SearchLocationsApiLocationsSearchGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchLocationsApiLocationsSearchGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSearchLocationsApiLocationsSearchGetQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get occupancy information for all locations
 * @summary Get Locations Occupancy
 */
export const getLocationsOccupancyApiLocationsOccupancyGet = (
    
 signal?: AbortSignal
) => {
      
      
      return apiClient<unknown>(
      {url: `/api/locations/occupancy`, method: 'GET', signal
    },
      );
    }
  

export const getGetLocationsOccupancyApiLocationsOccupancyGetQueryKey = () => {
    return [`/api/locations/occupancy`] as const;
    }

    
export const getGetLocationsOccupancyApiLocationsOccupancyGetQueryOptions = <TData = Awaited<ReturnType<typeof getLocationsOccupancyApiLocationsOccupancyGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLocationsOccupancyApiLocationsOccupancyGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetLocationsOccupancyApiLocationsOccupancyGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getLocationsOccupancyApiLocationsOccupancyGet>>> = ({ signal }) => getLocationsOccupancyApiLocationsOccupancyGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getLocationsOccupancyApiLocationsOccupancyGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetLocationsOccupancyApiLocationsOccupancyGetQueryResult = NonNullable<Awaited<ReturnType<typeof getLocationsOccupancyApiLocationsOccupancyGet>>>
export type GetLocationsOccupancyApiLocationsOccupancyGetQueryError = unknown


export function useGetLocationsOccupancyApiLocationsOccupancyGet<TData = Awaited<ReturnType<typeof getLocationsOccupancyApiLocationsOccupancyGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLocationsOccupancyApiLocationsOccupancyGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLocationsOccupancyApiLocationsOccupancyGet>>,
          TError,
          Awaited<ReturnType<typeof getLocationsOccupancyApiLocationsOccupancyGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetLocationsOccupancyApiLocationsOccupancyGet<TData = Awaited<ReturnType<typeof getLocationsOccupancyApiLocationsOccupancyGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLocationsOccupancyApiLocationsOccupancyGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLocationsOccupancyApiLocationsOccupancyGet>>,
          TError,
          Awaited<ReturnType<typeof getLocationsOccupancyApiLocationsOccupancyGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetLocationsOccupancyApiLocationsOccupancyGet<TData = Awaited<ReturnType<typeof getLocationsOccupancyApiLocationsOccupancyGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLocationsOccupancyApiLocationsOccupancyGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Locations Occupancy
 */

export function useGetLocationsOccupancyApiLocationsOccupancyGet<TData = Awaited<ReturnType<typeof getLocationsOccupancyApiLocationsOccupancyGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLocationsOccupancyApiLocationsOccupancyGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetLocationsOccupancyApiLocationsOccupancyGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get locations that have available space
 * @summary Get Available Locations
 */
export const getAvailableLocationsApiLocationsAvailableGet = (
    params?: GetAvailableLocationsApiLocationsAvailableGetParams,
 signal?: AbortSignal
) => {
      
      
      return apiClient<unknown>(
      {url: `/api/locations/available`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetAvailableLocationsApiLocationsAvailableGetQueryKey = (params?: GetAvailableLocationsApiLocationsAvailableGetParams,) => {
    return [`/api/locations/available`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAvailableLocationsApiLocationsAvailableGetQueryOptions = <TData = Awaited<ReturnType<typeof getAvailableLocationsApiLocationsAvailableGet>>, TError = HTTPValidationError>(params?: GetAvailableLocationsApiLocationsAvailableGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableLocationsApiLocationsAvailableGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAvailableLocationsApiLocationsAvailableGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAvailableLocationsApiLocationsAvailableGet>>> = ({ signal }) => getAvailableLocationsApiLocationsAvailableGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAvailableLocationsApiLocationsAvailableGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAvailableLocationsApiLocationsAvailableGetQueryResult = NonNullable<Awaited<ReturnType<typeof getAvailableLocationsApiLocationsAvailableGet>>>
export type GetAvailableLocationsApiLocationsAvailableGetQueryError = HTTPValidationError


export function useGetAvailableLocationsApiLocationsAvailableGet<TData = Awaited<ReturnType<typeof getAvailableLocationsApiLocationsAvailableGet>>, TError = HTTPValidationError>(
 params: undefined |  GetAvailableLocationsApiLocationsAvailableGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableLocationsApiLocationsAvailableGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableLocationsApiLocationsAvailableGet>>,
          TError,
          Awaited<ReturnType<typeof getAvailableLocationsApiLocationsAvailableGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableLocationsApiLocationsAvailableGet<TData = Awaited<ReturnType<typeof getAvailableLocationsApiLocationsAvailableGet>>, TError = HTTPValidationError>(
 params?: GetAvailableLocationsApiLocationsAvailableGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableLocationsApiLocationsAvailableGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableLocationsApiLocationsAvailableGet>>,
          TError,
          Awaited<ReturnType<typeof getAvailableLocationsApiLocationsAvailableGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableLocationsApiLocationsAvailableGet<TData = Awaited<ReturnType<typeof getAvailableLocationsApiLocationsAvailableGet>>, TError = HTTPValidationError>(
 params?: GetAvailableLocationsApiLocationsAvailableGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableLocationsApiLocationsAvailableGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Available Locations
 */

export function useGetAvailableLocationsApiLocationsAvailableGet<TData = Awaited<ReturnType<typeof getAvailableLocationsApiLocationsAvailableGet>>, TError = HTTPValidationError>(
 params?: GetAvailableLocationsApiLocationsAvailableGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableLocationsApiLocationsAvailableGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAvailableLocationsApiLocationsAvailableGetQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get a single location with animals
 * @summary Read Location
 */
export const readLocationApiLocationsLocationIdGet = (
    locationId: number,
 signal?: AbortSignal
) => {
      
      
      return apiClient<LocationWithAnimals>(
      {url: `/api/locations/${locationId}`, method: 'GET', signal
    },
      );
    }
  

export const getReadLocationApiLocationsLocationIdGetQueryKey = (locationId?: number,) => {
    return [`/api/locations/${locationId}`] as const;
    }

    
export const getReadLocationApiLocationsLocationIdGetQueryOptions = <TData = Awaited<ReturnType<typeof readLocationApiLocationsLocationIdGet>>, TError = HTTPValidationError>(locationId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readLocationApiLocationsLocationIdGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadLocationApiLocationsLocationIdGetQueryKey(locationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readLocationApiLocationsLocationIdGet>>> = ({ signal }) => readLocationApiLocationsLocationIdGet(locationId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(locationId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readLocationApiLocationsLocationIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadLocationApiLocationsLocationIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof readLocationApiLocationsLocationIdGet>>>
export type ReadLocationApiLocationsLocationIdGetQueryError = HTTPValidationError


export function useReadLocationApiLocationsLocationIdGet<TData = Awaited<ReturnType<typeof readLocationApiLocationsLocationIdGet>>, TError = HTTPValidationError>(
 locationId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readLocationApiLocationsLocationIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readLocationApiLocationsLocationIdGet>>,
          TError,
          Awaited<ReturnType<typeof readLocationApiLocationsLocationIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadLocationApiLocationsLocationIdGet<TData = Awaited<ReturnType<typeof readLocationApiLocationsLocationIdGet>>, TError = HTTPValidationError>(
 locationId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readLocationApiLocationsLocationIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readLocationApiLocationsLocationIdGet>>,
          TError,
          Awaited<ReturnType<typeof readLocationApiLocationsLocationIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadLocationApiLocationsLocationIdGet<TData = Awaited<ReturnType<typeof readLocationApiLocationsLocationIdGet>>, TError = HTTPValidationError>(
 locationId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readLocationApiLocationsLocationIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Location
 */

export function useReadLocationApiLocationsLocationIdGet<TData = Awaited<ReturnType<typeof readLocationApiLocationsLocationIdGet>>, TError = HTTPValidationError>(
 locationId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readLocationApiLocationsLocationIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadLocationApiLocationsLocationIdGetQueryOptions(locationId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an existing location
 * @summary Update Location
 */
export const updateLocationApiLocationsLocationIdPut = (
    locationId: number,
    locationUpdate: LocationUpdate,
 ) => {
      
      
      return apiClient<Location>(
      {url: `/api/locations/${locationId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: locationUpdate
    },
      );
    }
  


export const getUpdateLocationApiLocationsLocationIdPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateLocationApiLocationsLocationIdPut>>, TError,{locationId: number;data: LocationUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateLocationApiLocationsLocationIdPut>>, TError,{locationId: number;data: LocationUpdate}, TContext> => {

const mutationKey = ['updateLocationApiLocationsLocationIdPut'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateLocationApiLocationsLocationIdPut>>, {locationId: number;data: LocationUpdate}> = (props) => {
          const {locationId,data} = props ?? {};

          return  updateLocationApiLocationsLocationIdPut(locationId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateLocationApiLocationsLocationIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateLocationApiLocationsLocationIdPut>>>
    export type UpdateLocationApiLocationsLocationIdPutMutationBody = LocationUpdate
    export type UpdateLocationApiLocationsLocationIdPutMutationError = HTTPValidationError

    /**
 * @summary Update Location
 */
export const useUpdateLocationApiLocationsLocationIdPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateLocationApiLocationsLocationIdPut>>, TError,{locationId: number;data: LocationUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateLocationApiLocationsLocationIdPut>>,
        TError,
        {locationId: number;data: LocationUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateLocationApiLocationsLocationIdPutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a location
 * @summary Delete Location
 */
export const deleteLocationApiLocationsLocationIdDelete = (
    locationId: number,
 ) => {
      
      
      return apiClient<unknown>(
      {url: `/api/locations/${locationId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteLocationApiLocationsLocationIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteLocationApiLocationsLocationIdDelete>>, TError,{locationId: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteLocationApiLocationsLocationIdDelete>>, TError,{locationId: number}, TContext> => {

const mutationKey = ['deleteLocationApiLocationsLocationIdDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteLocationApiLocationsLocationIdDelete>>, {locationId: number}> = (props) => {
          const {locationId} = props ?? {};

          return  deleteLocationApiLocationsLocationIdDelete(locationId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteLocationApiLocationsLocationIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteLocationApiLocationsLocationIdDelete>>>
    
    export type DeleteLocationApiLocationsLocationIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Location
 */
export const useDeleteLocationApiLocationsLocationIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteLocationApiLocationsLocationIdDelete>>, TError,{locationId: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteLocationApiLocationsLocationIdDelete>>,
        TError,
        {locationId: number},
        TContext
      > => {

      const mutationOptions = getDeleteLocationApiLocationsLocationIdDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get all animals currently at a specific location
 * @summary Get Animals At Location
 */
export const getAnimalsAtLocationApiLocationsLocationIdAnimalsGet = (
    locationId: number,
 signal?: AbortSignal
) => {
      
      
      return apiClient<Animal[]>(
      {url: `/api/locations/${locationId}/animals`, method: 'GET', signal
    },
      );
    }
  

export const getGetAnimalsAtLocationApiLocationsLocationIdAnimalsGetQueryKey = (locationId?: number,) => {
    return [`/api/locations/${locationId}/animals`] as const;
    }

    
export const getGetAnimalsAtLocationApiLocationsLocationIdAnimalsGetQueryOptions = <TData = Awaited<ReturnType<typeof getAnimalsAtLocationApiLocationsLocationIdAnimalsGet>>, TError = HTTPValidationError>(locationId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimalsAtLocationApiLocationsLocationIdAnimalsGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimalsAtLocationApiLocationsLocationIdAnimalsGetQueryKey(locationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimalsAtLocationApiLocationsLocationIdAnimalsGet>>> = ({ signal }) => getAnimalsAtLocationApiLocationsLocationIdAnimalsGet(locationId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(locationId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAnimalsAtLocationApiLocationsLocationIdAnimalsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAnimalsAtLocationApiLocationsLocationIdAnimalsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimalsAtLocationApiLocationsLocationIdAnimalsGet>>>
export type GetAnimalsAtLocationApiLocationsLocationIdAnimalsGetQueryError = HTTPValidationError


export function useGetAnimalsAtLocationApiLocationsLocationIdAnimalsGet<TData = Awaited<ReturnType<typeof getAnimalsAtLocationApiLocationsLocationIdAnimalsGet>>, TError = HTTPValidationError>(
 locationId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimalsAtLocationApiLocationsLocationIdAnimalsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAnimalsAtLocationApiLocationsLocationIdAnimalsGet>>,
          TError,
          Awaited<ReturnType<typeof getAnimalsAtLocationApiLocationsLocationIdAnimalsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAnimalsAtLocationApiLocationsLocationIdAnimalsGet<TData = Awaited<ReturnType<typeof getAnimalsAtLocationApiLocationsLocationIdAnimalsGet>>, TError = HTTPValidationError>(
 locationId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimalsAtLocationApiLocationsLocationIdAnimalsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAnimalsAtLocationApiLocationsLocationIdAnimalsGet>>,
          TError,
          Awaited<ReturnType<typeof getAnimalsAtLocationApiLocationsLocationIdAnimalsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAnimalsAtLocationApiLocationsLocationIdAnimalsGet<TData = Awaited<ReturnType<typeof getAnimalsAtLocationApiLocationsLocationIdAnimalsGet>>, TError = HTTPValidationError>(
 locationId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimalsAtLocationApiLocationsLocationIdAnimalsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Animals At Location
 */

export function useGetAnimalsAtLocationApiLocationsLocationIdAnimalsGet<TData = Awaited<ReturnType<typeof getAnimalsAtLocationApiLocationsLocationIdAnimalsGet>>, TError = HTTPValidationError>(
 locationId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimalsAtLocationApiLocationsLocationIdAnimalsGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAnimalsAtLocationApiLocationsLocationIdAnimalsGetQueryOptions(locationId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get occupancy information for a specific location
 * @summary Get Location Occupancy
 */
export const getLocationOccupancyApiLocationsLocationIdOccupancyGet = (
    locationId: number,
 signal?: AbortSignal
) => {
      
      
      return apiClient<unknown>(
      {url: `/api/locations/${locationId}/occupancy`, method: 'GET', signal
    },
      );
    }
  

export const getGetLocationOccupancyApiLocationsLocationIdOccupancyGetQueryKey = (locationId?: number,) => {
    return [`/api/locations/${locationId}/occupancy`] as const;
    }

    
export const getGetLocationOccupancyApiLocationsLocationIdOccupancyGetQueryOptions = <TData = Awaited<ReturnType<typeof getLocationOccupancyApiLocationsLocationIdOccupancyGet>>, TError = HTTPValidationError>(locationId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLocationOccupancyApiLocationsLocationIdOccupancyGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetLocationOccupancyApiLocationsLocationIdOccupancyGetQueryKey(locationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getLocationOccupancyApiLocationsLocationIdOccupancyGet>>> = ({ signal }) => getLocationOccupancyApiLocationsLocationIdOccupancyGet(locationId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(locationId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getLocationOccupancyApiLocationsLocationIdOccupancyGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetLocationOccupancyApiLocationsLocationIdOccupancyGetQueryResult = NonNullable<Awaited<ReturnType<typeof getLocationOccupancyApiLocationsLocationIdOccupancyGet>>>
export type GetLocationOccupancyApiLocationsLocationIdOccupancyGetQueryError = HTTPValidationError


export function useGetLocationOccupancyApiLocationsLocationIdOccupancyGet<TData = Awaited<ReturnType<typeof getLocationOccupancyApiLocationsLocationIdOccupancyGet>>, TError = HTTPValidationError>(
 locationId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLocationOccupancyApiLocationsLocationIdOccupancyGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLocationOccupancyApiLocationsLocationIdOccupancyGet>>,
          TError,
          Awaited<ReturnType<typeof getLocationOccupancyApiLocationsLocationIdOccupancyGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetLocationOccupancyApiLocationsLocationIdOccupancyGet<TData = Awaited<ReturnType<typeof getLocationOccupancyApiLocationsLocationIdOccupancyGet>>, TError = HTTPValidationError>(
 locationId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLocationOccupancyApiLocationsLocationIdOccupancyGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLocationOccupancyApiLocationsLocationIdOccupancyGet>>,
          TError,
          Awaited<ReturnType<typeof getLocationOccupancyApiLocationsLocationIdOccupancyGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetLocationOccupancyApiLocationsLocationIdOccupancyGet<TData = Awaited<ReturnType<typeof getLocationOccupancyApiLocationsLocationIdOccupancyGet>>, TError = HTTPValidationError>(
 locationId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLocationOccupancyApiLocationsLocationIdOccupancyGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Location Occupancy
 */

export function useGetLocationOccupancyApiLocationsLocationIdOccupancyGet<TData = Awaited<ReturnType<typeof getLocationOccupancyApiLocationsLocationIdOccupancyGet>>, TError = HTTPValidationError>(
 locationId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLocationOccupancyApiLocationsLocationIdOccupancyGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetLocationOccupancyApiLocationsLocationIdOccupancyGetQueryOptions(locationId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Move multiple animals from one location to another
 * @summary Move Animals Between Locations
 */
export const moveAnimalsBetweenLocationsApiLocationsMoveAnimalsPost = (
    moveAnimalsBetweenLocationsApiLocationsMoveAnimalsPostBody: number[],
    params: MoveAnimalsBetweenLocationsApiLocationsMoveAnimalsPostParams,
 signal?: AbortSignal
) => {
      
      
      return apiClient<unknown>(
      {url: `/api/locations/move-animals`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: moveAnimalsBetweenLocationsApiLocationsMoveAnimalsPostBody,
        params, signal
    },
      );
    }
  


export const getMoveAnimalsBetweenLocationsApiLocationsMoveAnimalsPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof moveAnimalsBetweenLocationsApiLocationsMoveAnimalsPost>>, TError,{data: number[];params: MoveAnimalsBetweenLocationsApiLocationsMoveAnimalsPostParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof moveAnimalsBetweenLocationsApiLocationsMoveAnimalsPost>>, TError,{data: number[];params: MoveAnimalsBetweenLocationsApiLocationsMoveAnimalsPostParams}, TContext> => {

const mutationKey = ['moveAnimalsBetweenLocationsApiLocationsMoveAnimalsPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof moveAnimalsBetweenLocationsApiLocationsMoveAnimalsPost>>, {data: number[];params: MoveAnimalsBetweenLocationsApiLocationsMoveAnimalsPostParams}> = (props) => {
          const {data,params} = props ?? {};

          return  moveAnimalsBetweenLocationsApiLocationsMoveAnimalsPost(data,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type MoveAnimalsBetweenLocationsApiLocationsMoveAnimalsPostMutationResult = NonNullable<Awaited<ReturnType<typeof moveAnimalsBetweenLocationsApiLocationsMoveAnimalsPost>>>
    export type MoveAnimalsBetweenLocationsApiLocationsMoveAnimalsPostMutationBody = number[]
    export type MoveAnimalsBetweenLocationsApiLocationsMoveAnimalsPostMutationError = HTTPValidationError

    /**
 * @summary Move Animals Between Locations
 */
export const useMoveAnimalsBetweenLocationsApiLocationsMoveAnimalsPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof moveAnimalsBetweenLocationsApiLocationsMoveAnimalsPost>>, TError,{data: number[];params: MoveAnimalsBetweenLocationsApiLocationsMoveAnimalsPostParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof moveAnimalsBetweenLocationsApiLocationsMoveAnimalsPost>>,
        TError,
        {data: number[];params: MoveAnimalsBetweenLocationsApiLocationsMoveAnimalsPostParams},
        TContext
      > => {

      const mutationOptions = getMoveAnimalsBetweenLocationsApiLocationsMoveAnimalsPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Upload a photograph for an animal
 * @summary Upload Photograph
 */
export const uploadPhotographApiPhotographsUploadAnimalIdPost = (
    animalId: number,
    bodyUploadPhotographApiPhotographsUploadAnimalIdPost: BodyUploadPhotographApiPhotographsUploadAnimalIdPost,
 signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append(`file`, bodyUploadPhotographApiPhotographsUploadAnimalIdPost.file)
if(bodyUploadPhotographApiPhotographsUploadAnimalIdPost.caption !== undefined && bodyUploadPhotographApiPhotographsUploadAnimalIdPost.caption !== null) {
 formData.append(`caption`, bodyUploadPhotographApiPhotographsUploadAnimalIdPost.caption)
 }
if(bodyUploadPhotographApiPhotographsUploadAnimalIdPost.description !== undefined && bodyUploadPhotographApiPhotographsUploadAnimalIdPost.description !== null) {
 formData.append(`description`, bodyUploadPhotographApiPhotographsUploadAnimalIdPost.description)
 }
if(bodyUploadPhotographApiPhotographsUploadAnimalIdPost.is_primary !== undefined) {
 formData.append(`is_primary`, bodyUploadPhotographApiPhotographsUploadAnimalIdPost.is_primary.toString())
 }

      return apiClient<PhotographUploadResponse>(
      {url: `/api/photographs/upload/${animalId}`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      );
    }
  


export const getUploadPhotographApiPhotographsUploadAnimalIdPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadPhotographApiPhotographsUploadAnimalIdPost>>, TError,{animalId: number;data: BodyUploadPhotographApiPhotographsUploadAnimalIdPost}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof uploadPhotographApiPhotographsUploadAnimalIdPost>>, TError,{animalId: number;data: BodyUploadPhotographApiPhotographsUploadAnimalIdPost}, TContext> => {

const mutationKey = ['uploadPhotographApiPhotographsUploadAnimalIdPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof uploadPhotographApiPhotographsUploadAnimalIdPost>>, {animalId: number;data: BodyUploadPhotographApiPhotographsUploadAnimalIdPost}> = (props) => {
          const {animalId,data} = props ?? {};

          return  uploadPhotographApiPhotographsUploadAnimalIdPost(animalId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UploadPhotographApiPhotographsUploadAnimalIdPostMutationResult = NonNullable<Awaited<ReturnType<typeof uploadPhotographApiPhotographsUploadAnimalIdPost>>>
    export type UploadPhotographApiPhotographsUploadAnimalIdPostMutationBody = BodyUploadPhotographApiPhotographsUploadAnimalIdPost
    export type UploadPhotographApiPhotographsUploadAnimalIdPostMutationError = HTTPValidationError

    /**
 * @summary Upload Photograph
 */
export const useUploadPhotographApiPhotographsUploadAnimalIdPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadPhotographApiPhotographsUploadAnimalIdPost>>, TError,{animalId: number;data: BodyUploadPhotographApiPhotographsUploadAnimalIdPost}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof uploadPhotographApiPhotographsUploadAnimalIdPost>>,
        TError,
        {animalId: number;data: BodyUploadPhotographApiPhotographsUploadAnimalIdPost},
        TContext
      > => {

      const mutationOptions = getUploadPhotographApiPhotographsUploadAnimalIdPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get all photographs for an animal
 * @summary Get Animal Photographs
 */
export const getAnimalPhotographsApiPhotographsAnimalAnimalIdGet = (
    animalId: number,
 signal?: AbortSignal
) => {
      
      
      return apiClient<Photograph[]>(
      {url: `/api/photographs/animal/${animalId}`, method: 'GET', signal
    },
      );
    }
  

export const getGetAnimalPhotographsApiPhotographsAnimalAnimalIdGetQueryKey = (animalId?: number,) => {
    return [`/api/photographs/animal/${animalId}`] as const;
    }

    
export const getGetAnimalPhotographsApiPhotographsAnimalAnimalIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getAnimalPhotographsApiPhotographsAnimalAnimalIdGet>>, TError = HTTPValidationError>(animalId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimalPhotographsApiPhotographsAnimalAnimalIdGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnimalPhotographsApiPhotographsAnimalAnimalIdGetQueryKey(animalId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnimalPhotographsApiPhotographsAnimalAnimalIdGet>>> = ({ signal }) => getAnimalPhotographsApiPhotographsAnimalAnimalIdGet(animalId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(animalId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAnimalPhotographsApiPhotographsAnimalAnimalIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAnimalPhotographsApiPhotographsAnimalAnimalIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getAnimalPhotographsApiPhotographsAnimalAnimalIdGet>>>
export type GetAnimalPhotographsApiPhotographsAnimalAnimalIdGetQueryError = HTTPValidationError


export function useGetAnimalPhotographsApiPhotographsAnimalAnimalIdGet<TData = Awaited<ReturnType<typeof getAnimalPhotographsApiPhotographsAnimalAnimalIdGet>>, TError = HTTPValidationError>(
 animalId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimalPhotographsApiPhotographsAnimalAnimalIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAnimalPhotographsApiPhotographsAnimalAnimalIdGet>>,
          TError,
          Awaited<ReturnType<typeof getAnimalPhotographsApiPhotographsAnimalAnimalIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAnimalPhotographsApiPhotographsAnimalAnimalIdGet<TData = Awaited<ReturnType<typeof getAnimalPhotographsApiPhotographsAnimalAnimalIdGet>>, TError = HTTPValidationError>(
 animalId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimalPhotographsApiPhotographsAnimalAnimalIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAnimalPhotographsApiPhotographsAnimalAnimalIdGet>>,
          TError,
          Awaited<ReturnType<typeof getAnimalPhotographsApiPhotographsAnimalAnimalIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAnimalPhotographsApiPhotographsAnimalAnimalIdGet<TData = Awaited<ReturnType<typeof getAnimalPhotographsApiPhotographsAnimalAnimalIdGet>>, TError = HTTPValidationError>(
 animalId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimalPhotographsApiPhotographsAnimalAnimalIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Animal Photographs
 */

export function useGetAnimalPhotographsApiPhotographsAnimalAnimalIdGet<TData = Awaited<ReturnType<typeof getAnimalPhotographsApiPhotographsAnimalAnimalIdGet>>, TError = HTTPValidationError>(
 animalId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAnimalPhotographsApiPhotographsAnimalAnimalIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAnimalPhotographsApiPhotographsAnimalAnimalIdGetQueryOptions(animalId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get a specific photograph
 * @summary Get Photograph
 */
export const getPhotographApiPhotographsPhotographIdGet = (
    photographId: number,
 signal?: AbortSignal
) => {
      
      
      return apiClient<Photograph>(
      {url: `/api/photographs/${photographId}`, method: 'GET', signal
    },
      );
    }
  

export const getGetPhotographApiPhotographsPhotographIdGetQueryKey = (photographId?: number,) => {
    return [`/api/photographs/${photographId}`] as const;
    }

    
export const getGetPhotographApiPhotographsPhotographIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getPhotographApiPhotographsPhotographIdGet>>, TError = HTTPValidationError>(photographId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotographApiPhotographsPhotographIdGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPhotographApiPhotographsPhotographIdGetQueryKey(photographId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPhotographApiPhotographsPhotographIdGet>>> = ({ signal }) => getPhotographApiPhotographsPhotographIdGet(photographId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(photographId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPhotographApiPhotographsPhotographIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPhotographApiPhotographsPhotographIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getPhotographApiPhotographsPhotographIdGet>>>
export type GetPhotographApiPhotographsPhotographIdGetQueryError = HTTPValidationError


export function useGetPhotographApiPhotographsPhotographIdGet<TData = Awaited<ReturnType<typeof getPhotographApiPhotographsPhotographIdGet>>, TError = HTTPValidationError>(
 photographId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotographApiPhotographsPhotographIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPhotographApiPhotographsPhotographIdGet>>,
          TError,
          Awaited<ReturnType<typeof getPhotographApiPhotographsPhotographIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPhotographApiPhotographsPhotographIdGet<TData = Awaited<ReturnType<typeof getPhotographApiPhotographsPhotographIdGet>>, TError = HTTPValidationError>(
 photographId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotographApiPhotographsPhotographIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPhotographApiPhotographsPhotographIdGet>>,
          TError,
          Awaited<ReturnType<typeof getPhotographApiPhotographsPhotographIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPhotographApiPhotographsPhotographIdGet<TData = Awaited<ReturnType<typeof getPhotographApiPhotographsPhotographIdGet>>, TError = HTTPValidationError>(
 photographId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotographApiPhotographsPhotographIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Photograph
 */

export function useGetPhotographApiPhotographsPhotographIdGet<TData = Awaited<ReturnType<typeof getPhotographApiPhotographsPhotographIdGet>>, TError = HTTPValidationError>(
 photographId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotographApiPhotographsPhotographIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPhotographApiPhotographsPhotographIdGetQueryOptions(photographId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update photograph metadata
 * @summary Update Photograph
 */
export const updatePhotographApiPhotographsPhotographIdPut = (
    photographId: number,
    photographUpdate: PhotographUpdate,
 ) => {
      
      
      return apiClient<Photograph>(
      {url: `/api/photographs/${photographId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: photographUpdate
    },
      );
    }
  


export const getUpdatePhotographApiPhotographsPhotographIdPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePhotographApiPhotographsPhotographIdPut>>, TError,{photographId: number;data: PhotographUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updatePhotographApiPhotographsPhotographIdPut>>, TError,{photographId: number;data: PhotographUpdate}, TContext> => {

const mutationKey = ['updatePhotographApiPhotographsPhotographIdPut'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePhotographApiPhotographsPhotographIdPut>>, {photographId: number;data: PhotographUpdate}> = (props) => {
          const {photographId,data} = props ?? {};

          return  updatePhotographApiPhotographsPhotographIdPut(photographId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatePhotographApiPhotographsPhotographIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updatePhotographApiPhotographsPhotographIdPut>>>
    export type UpdatePhotographApiPhotographsPhotographIdPutMutationBody = PhotographUpdate
    export type UpdatePhotographApiPhotographsPhotographIdPutMutationError = HTTPValidationError

    /**
 * @summary Update Photograph
 */
export const useUpdatePhotographApiPhotographsPhotographIdPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePhotographApiPhotographsPhotographIdPut>>, TError,{photographId: number;data: PhotographUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updatePhotographApiPhotographsPhotographIdPut>>,
        TError,
        {photographId: number;data: PhotographUpdate},
        TContext
      > => {

      const mutationOptions = getUpdatePhotographApiPhotographsPhotographIdPutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a photograph
 * @summary Delete Photograph
 */
export const deletePhotographApiPhotographsPhotographIdDelete = (
    photographId: number,
 ) => {
      
      
      return apiClient<unknown>(
      {url: `/api/photographs/${photographId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeletePhotographApiPhotographsPhotographIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePhotographApiPhotographsPhotographIdDelete>>, TError,{photographId: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deletePhotographApiPhotographsPhotographIdDelete>>, TError,{photographId: number}, TContext> => {

const mutationKey = ['deletePhotographApiPhotographsPhotographIdDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePhotographApiPhotographsPhotographIdDelete>>, {photographId: number}> = (props) => {
          const {photographId} = props ?? {};

          return  deletePhotographApiPhotographsPhotographIdDelete(photographId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletePhotographApiPhotographsPhotographIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deletePhotographApiPhotographsPhotographIdDelete>>>
    
    export type DeletePhotographApiPhotographsPhotographIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Photograph
 */
export const useDeletePhotographApiPhotographsPhotographIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePhotographApiPhotographsPhotographIdDelete>>, TError,{photographId: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deletePhotographApiPhotographsPhotographIdDelete>>,
        TError,
        {photographId: number},
        TContext
      > => {

      const mutationOptions = getDeletePhotographApiPhotographsPhotographIdDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Serve the actual image file
 * @summary Get Photograph File
 */
export const getPhotographFileApiPhotographsPhotographIdFileGet = (
    photographId: number,
 signal?: AbortSignal
) => {
      
      
      return apiClient<unknown>(
      {url: `/api/photographs/${photographId}/file`, method: 'GET', signal
    },
      );
    }
  

export const getGetPhotographFileApiPhotographsPhotographIdFileGetQueryKey = (photographId?: number,) => {
    return [`/api/photographs/${photographId}/file`] as const;
    }

    
export const getGetPhotographFileApiPhotographsPhotographIdFileGetQueryOptions = <TData = Awaited<ReturnType<typeof getPhotographFileApiPhotographsPhotographIdFileGet>>, TError = HTTPValidationError>(photographId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotographFileApiPhotographsPhotographIdFileGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPhotographFileApiPhotographsPhotographIdFileGetQueryKey(photographId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPhotographFileApiPhotographsPhotographIdFileGet>>> = ({ signal }) => getPhotographFileApiPhotographsPhotographIdFileGet(photographId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(photographId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPhotographFileApiPhotographsPhotographIdFileGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPhotographFileApiPhotographsPhotographIdFileGetQueryResult = NonNullable<Awaited<ReturnType<typeof getPhotographFileApiPhotographsPhotographIdFileGet>>>
export type GetPhotographFileApiPhotographsPhotographIdFileGetQueryError = HTTPValidationError


export function useGetPhotographFileApiPhotographsPhotographIdFileGet<TData = Awaited<ReturnType<typeof getPhotographFileApiPhotographsPhotographIdFileGet>>, TError = HTTPValidationError>(
 photographId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotographFileApiPhotographsPhotographIdFileGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPhotographFileApiPhotographsPhotographIdFileGet>>,
          TError,
          Awaited<ReturnType<typeof getPhotographFileApiPhotographsPhotographIdFileGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPhotographFileApiPhotographsPhotographIdFileGet<TData = Awaited<ReturnType<typeof getPhotographFileApiPhotographsPhotographIdFileGet>>, TError = HTTPValidationError>(
 photographId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotographFileApiPhotographsPhotographIdFileGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPhotographFileApiPhotographsPhotographIdFileGet>>,
          TError,
          Awaited<ReturnType<typeof getPhotographFileApiPhotographsPhotographIdFileGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPhotographFileApiPhotographsPhotographIdFileGet<TData = Awaited<ReturnType<typeof getPhotographFileApiPhotographsPhotographIdFileGet>>, TError = HTTPValidationError>(
 photographId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotographFileApiPhotographsPhotographIdFileGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Photograph File
 */

export function useGetPhotographFileApiPhotographsPhotographIdFileGet<TData = Awaited<ReturnType<typeof getPhotographFileApiPhotographsPhotographIdFileGet>>, TError = HTTPValidationError>(
 photographId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotographFileApiPhotographsPhotographIdFileGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPhotographFileApiPhotographsPhotographIdFileGetQueryOptions(photographId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Set a photograph as the primary photo for an animal
 * @summary Set Primary Photograph
 */
export const setPrimaryPhotographApiPhotographsPhotographIdSetPrimaryPost = (
    photographId: number,
 signal?: AbortSignal
) => {
      
      
      return apiClient<unknown>(
      {url: `/api/photographs/${photographId}/set-primary`, method: 'POST', signal
    },
      );
    }
  


export const getSetPrimaryPhotographApiPhotographsPhotographIdSetPrimaryPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof setPrimaryPhotographApiPhotographsPhotographIdSetPrimaryPost>>, TError,{photographId: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof setPrimaryPhotographApiPhotographsPhotographIdSetPrimaryPost>>, TError,{photographId: number}, TContext> => {

const mutationKey = ['setPrimaryPhotographApiPhotographsPhotographIdSetPrimaryPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof setPrimaryPhotographApiPhotographsPhotographIdSetPrimaryPost>>, {photographId: number}> = (props) => {
          const {photographId} = props ?? {};

          return  setPrimaryPhotographApiPhotographsPhotographIdSetPrimaryPost(photographId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SetPrimaryPhotographApiPhotographsPhotographIdSetPrimaryPostMutationResult = NonNullable<Awaited<ReturnType<typeof setPrimaryPhotographApiPhotographsPhotographIdSetPrimaryPost>>>
    
    export type SetPrimaryPhotographApiPhotographsPhotographIdSetPrimaryPostMutationError = HTTPValidationError

    /**
 * @summary Set Primary Photograph
 */
export const useSetPrimaryPhotographApiPhotographsPhotographIdSetPrimaryPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof setPrimaryPhotographApiPhotographsPhotographIdSetPrimaryPost>>, TError,{photographId: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof setPrimaryPhotographApiPhotographsPhotographIdSetPrimaryPost>>,
        TError,
        {photographId: number},
        TContext
      > => {

      const mutationOptions = getSetPrimaryPhotographApiPhotographsPhotographIdSetPrimaryPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * API information endpoint
 * @summary Api Info
 */
export const apiInfoApiGet = (
    
 signal?: AbortSignal
) => {
      
      
      return apiClient<unknown>(
      {url: `/api`, method: 'GET', signal
    },
      );
    }
  

export const getApiInfoApiGetQueryKey = () => {
    return [`/api`] as const;
    }

    
export const getApiInfoApiGetQueryOptions = <TData = Awaited<ReturnType<typeof apiInfoApiGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiInfoApiGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiInfoApiGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiInfoApiGet>>> = ({ signal }) => apiInfoApiGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiInfoApiGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiInfoApiGetQueryResult = NonNullable<Awaited<ReturnType<typeof apiInfoApiGet>>>
export type ApiInfoApiGetQueryError = unknown


export function useApiInfoApiGet<TData = Awaited<ReturnType<typeof apiInfoApiGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiInfoApiGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiInfoApiGet>>,
          TError,
          Awaited<ReturnType<typeof apiInfoApiGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiInfoApiGet<TData = Awaited<ReturnType<typeof apiInfoApiGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiInfoApiGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiInfoApiGet>>,
          TError,
          Awaited<ReturnType<typeof apiInfoApiGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiInfoApiGet<TData = Awaited<ReturnType<typeof apiInfoApiGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiInfoApiGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Api Info
 */

export function useApiInfoApiGet<TData = Awaited<ReturnType<typeof apiInfoApiGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiInfoApiGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiInfoApiGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Health check endpoint
 * @summary Health Check
 */
export const healthCheckHealthGet = (
    
 signal?: AbortSignal
) => {
      
      
      return apiClient<unknown>(
      {url: `/health`, method: 'GET', signal
    },
      );
    }
  

export const getHealthCheckHealthGetQueryKey = () => {
    return [`/health`] as const;
    }

    
export const getHealthCheckHealthGetQueryOptions = <TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHealthCheckHealthGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof healthCheckHealthGet>>> = ({ signal }) => healthCheckHealthGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type HealthCheckHealthGetQueryResult = NonNullable<Awaited<ReturnType<typeof healthCheckHealthGet>>>
export type HealthCheckHealthGetQueryError = unknown


export function useHealthCheckHealthGet<TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheckHealthGet>>,
          TError,
          Awaited<ReturnType<typeof healthCheckHealthGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthCheckHealthGet<TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheckHealthGet>>,
          TError,
          Awaited<ReturnType<typeof healthCheckHealthGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthCheckHealthGet<TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Health Check
 */

export function useHealthCheckHealthGet<TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getHealthCheckHealthGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Serve the React frontend
 * @summary Serve Frontend
 */
export const serveFrontendGet = (
    
 signal?: AbortSignal
) => {
      
      
      return apiClient<void>(
      {url: `/`, method: 'GET', signal
    },
      );
    }
  

export const getServeFrontendGetQueryKey = () => {
    return [`/`] as const;
    }

    
export const getServeFrontendGetQueryOptions = <TData = Awaited<ReturnType<typeof serveFrontendGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveFrontendGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getServeFrontendGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof serveFrontendGet>>> = ({ signal }) => serveFrontendGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof serveFrontendGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ServeFrontendGetQueryResult = NonNullable<Awaited<ReturnType<typeof serveFrontendGet>>>
export type ServeFrontendGetQueryError = unknown


export function useServeFrontendGet<TData = Awaited<ReturnType<typeof serveFrontendGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveFrontendGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof serveFrontendGet>>,
          TError,
          Awaited<ReturnType<typeof serveFrontendGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useServeFrontendGet<TData = Awaited<ReturnType<typeof serveFrontendGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveFrontendGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof serveFrontendGet>>,
          TError,
          Awaited<ReturnType<typeof serveFrontendGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useServeFrontendGet<TData = Awaited<ReturnType<typeof serveFrontendGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveFrontendGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Serve Frontend
 */

export function useServeFrontendGet<TData = Awaited<ReturnType<typeof serveFrontendGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveFrontendGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getServeFrontendGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Serve React app for all non-API routes (SPA routing)
 * @summary Serve Spa
 */
export const serveSpaFullPathGet = (
    fullPath: string,
 signal?: AbortSignal
) => {
      
      
      return apiClient<void>(
      {url: `/${fullPath}`, method: 'GET', signal
    },
      );
    }
  

export const getServeSpaFullPathGetQueryKey = (fullPath?: string,) => {
    return [`/${fullPath}`] as const;
    }

    
export const getServeSpaFullPathGetQueryOptions = <TData = Awaited<ReturnType<typeof serveSpaFullPathGet>>, TError = HTTPValidationError>(fullPath: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveSpaFullPathGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getServeSpaFullPathGetQueryKey(fullPath);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof serveSpaFullPathGet>>> = ({ signal }) => serveSpaFullPathGet(fullPath, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(fullPath), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof serveSpaFullPathGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ServeSpaFullPathGetQueryResult = NonNullable<Awaited<ReturnType<typeof serveSpaFullPathGet>>>
export type ServeSpaFullPathGetQueryError = HTTPValidationError


export function useServeSpaFullPathGet<TData = Awaited<ReturnType<typeof serveSpaFullPathGet>>, TError = HTTPValidationError>(
 fullPath: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveSpaFullPathGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof serveSpaFullPathGet>>,
          TError,
          Awaited<ReturnType<typeof serveSpaFullPathGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useServeSpaFullPathGet<TData = Awaited<ReturnType<typeof serveSpaFullPathGet>>, TError = HTTPValidationError>(
 fullPath: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveSpaFullPathGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof serveSpaFullPathGet>>,
          TError,
          Awaited<ReturnType<typeof serveSpaFullPathGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useServeSpaFullPathGet<TData = Awaited<ReturnType<typeof serveSpaFullPathGet>>, TError = HTTPValidationError>(
 fullPath: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveSpaFullPathGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Serve Spa
 */

export function useServeSpaFullPathGet<TData = Awaited<ReturnType<typeof serveSpaFullPathGet>>, TError = HTTPValidationError>(
 fullPath: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveSpaFullPathGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getServeSpaFullPathGetQueryOptions(fullPath,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




